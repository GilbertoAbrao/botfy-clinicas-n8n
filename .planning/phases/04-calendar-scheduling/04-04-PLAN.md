---
phase: 04-calendar-scheduling
plan: 04
wave: 3
depends_on: [04-02, 04-03]
subsystem: calendar
tags: [conflict-detection, availability, buffer-time, validation]

files_modified:
  - src/lib/calendar/conflict-detection.ts (create)
  - src/lib/calendar/availability-calculator.ts (create)
  - src/app/api/agendamentos/route.ts (modify)
  - src/app/api/agendamentos/[id]/route.ts (modify)
  - src/components/calendar/appointment-modal.tsx (modify)

autonomous: true

must_haves:
  truths:
    - "System prevents double-booking same provider at same time"
    - "System shows available time slots considering provider schedule"
    - "System enforces buffer time between appointments (15 minutes)"
    - "Conflict detection runs before creating/updating appointments"
    - "User sees visual conflict warnings in calendar"
  artifacts:
    - "src/lib/calendar/conflict-detection.ts has O(n log n) interval algorithm"
    - "src/lib/calendar/availability-calculator.ts calculates free slots"
    - "API endpoints validate conflicts before INSERT/UPDATE"
  key_links:
    - "Attempting to book conflicting slot shows error message"
    - "Modal displays only available time slots"
---

# Phase 4 Plan 4: Conflict Detection and Availability

**Implement conflict detection to prevent double-booking, calculate available time slots, and enforce buffer times between appointments**

<objective>
Build robust conflict detection using interval overlap algorithm (O(n log n)) to prevent scheduling conflicts. Calculate available time slots based on provider working hours, existing appointments, and required buffer times. Validate all appointment operations (create/update) server-side before committing to database.
</objective>

<execution_context>
**Framework references:**
@~/.claude/get-shit-done/references/principles.md

**Research context:**
@.planning/phases/04-calendar-scheduling/04-RESEARCH.md

**Key research findings:**
- Use interval overlap algorithm, not nested loops (O(n log n) vs O(n²))
- Healthcare requires 15-30 minute buffer times between appointments
- Check conflicts server-side before INSERT/UPDATE (prevent race conditions)
- Visual indicators for conflicts improve UX
</execution_context>

<context>
**Project state:**
@.planning/STATE.md

**Prior work:**
- Plan 04-02: Appointment CRUD APIs with validation
- Plan 04-03: Multi-provider support with provider_id on appointments
- Research: Conflict detection pattern from 04-RESEARCH.md (Pattern 4)

**Requirements addressed:**
- CAL-04: See time slot availability
- Implicit: Prevent double-booking conflicts
- Implicit: Respect buffer times for provider wellbeing

**Buffer time strategy:**
- Default: 15 minutes between appointments
- Configurable per provider in future (Phase 7)
- For MVP: hardcoded 15 minute buffer
</context>

<tasks>
### Task 1: Create conflict detection utility

Create `src/lib/calendar/conflict-detection.ts` with interval overlap algorithm:

```typescript
import { TZDate } from "@date-fns/tz"

export interface TimeSlot {
  id?: string
  start: Date
  end: Date
  providerId: string
}

/**
 * Check if two time slots overlap
 * Overlap occurs if: slot1.start < slot2.end AND slot2.start < slot1.end
 */
export function hasOverlap(slot1: TimeSlot, slot2: TimeSlot): boolean {
  // Different providers = no conflict
  if (slot1.providerId !== slot2.providerId) return false

  // Exclude self when checking (for updates)
  if (slot1.id && slot2.id && slot1.id === slot2.id) return false

  // Overlap: start < other.end AND other.start < end
  return (
    slot1.start.getTime() < slot2.end.getTime() &&
    slot2.start.getTime() < slot1.end.getTime()
  )
}

/**
 * Find all conflicts for a proposed time slot
 * Returns array of conflicting appointment IDs
 */
export function findConflicts(
  proposedSlot: TimeSlot,
  existingSlots: TimeSlot[]
): TimeSlot[] {
  return existingSlots.filter(slot => hasOverlap(proposedSlot, slot))
}

/**
 * Check if a time slot is available (no conflicts)
 */
export function isSlotAvailable(
  proposedSlot: TimeSlot,
  existingSlots: TimeSlot[]
): boolean {
  return findConflicts(proposedSlot, existingSlots).length === 0
}

/**
 * Add buffer time to time slot
 * @param slot Original time slot
 * @param bufferMinutes Buffer time in minutes (default: 15)
 * @returns Time slot with buffer added to end
 */
export function addBufferTime(
  slot: TimeSlot,
  bufferMinutes: number = 15
): TimeSlot {
  return {
    ...slot,
    end: new Date(slot.end.getTime() + bufferMinutes * 60000),
  }
}
```

**Research reference:** Pattern 4 from 04-RESEARCH.md (Conflict Detection with Interval Tree)

**Acceptance:**
- hasOverlap correctly detects overlapping time slots
- Different providers never conflict
- Self-appointments excluded when checking updates
- Buffer time adds minutes to slot end

### Task 2: Create availability calculator

Create `src/lib/calendar/availability-calculator.ts`:

```typescript
import { TZDate, CLINIC_TIMEZONE, createClinicDate } from './time-zone-utils'
import { TimeSlot, addBufferTime, isSlotAvailable } from './conflict-detection'

interface ProviderSchedule {
  providerId: string
  workingHours: { start: string; end: string }[]  // e.g., ["08:00", "12:00"], ["14:00", "18:00"]
  appointmentDuration: number  // Default duration in minutes
  bufferMinutes: number  // Buffer between appointments
}

/**
 * Calculate available time slots for a provider on a specific date
 */
export function calculateAvailableSlots(
  date: Date,
  schedule: ProviderSchedule,
  existingAppointments: TimeSlot[]
): Date[] {
  const slots: Date[] = []

  for (const hours of schedule.workingHours) {
    const [startHour, startMin] = hours.start.split(':').map(Number)
    const [endHour, endMin] = hours.end.split(':').map(Number)

    const periodStart = createClinicDate(
      date.getFullYear(),
      date.getMonth(),
      date.getDate(),
      startHour,
      startMin
    )

    const periodEnd = createClinicDate(
      date.getFullYear(),
      date.getMonth(),
      date.getDate(),
      endHour,
      endMin
    )

    let current = periodStart
    const slotDuration = schedule.appointmentDuration + schedule.bufferMinutes

    // Generate all possible slots within working hours
    while (current.getTime() + (schedule.appointmentDuration * 60000) <= periodEnd.getTime()) {
      const slotEnd = new Date(current.getTime() + schedule.appointmentDuration * 60000)

      // Create proposed slot with buffer
      const proposedSlot: TimeSlot = {
        providerId: schedule.providerId,
        start: current,
        end: slotEnd,
      }

      const slotWithBuffer = addBufferTime(proposedSlot, schedule.bufferMinutes)

      // Check if slot is available (no conflicts)
      if (isSlotAvailable(slotWithBuffer, existingAppointments)) {
        slots.push(new Date(current))
      }

      // Move to next slot (appointment + buffer)
      current = new Date(current.getTime() + slotDuration * 60000)
    }
  }

  return slots
}

/**
 * Default working hours for MVP (8am-12pm, 2pm-6pm)
 * TODO: Move to provider configuration in Phase 7
 */
export const DEFAULT_WORKING_HOURS = [
  { start: '08:00', end: '12:00' },
  { start: '14:00', end: '18:00' },
]

export const DEFAULT_APPOINTMENT_DURATION = 60  // 1 hour
export const DEFAULT_BUFFER_MINUTES = 15  // 15 minutes buffer
```

**Research reference:** Pattern 5 from 04-RESEARCH.md (Buffer Time Management)

**Acceptance:**
- Calculates slots within working hours
- Respects existing appointments (no conflicts)
- Adds buffer time between slots
- Returns available slot start times

### Task 3: Add conflict validation to create appointment API

Modify `src/app/api/agendamentos/route.ts` POST endpoint:

```typescript
import { findConflicts, addBufferTime, TimeSlot } from '@/lib/calendar/conflict-detection'
import { createServerClient } from '@/lib/supabase/server'

export async function POST(req: NextRequest) {
  try {
    // ... existing auth and validation

    const validatedData = createAppointmentSchema.parse(body)
    const supabase = await createServerClient()

    // Fetch service to get duration
    const { data: service } = await supabase
      .from('servicos')
      .select('duracao_minutos')
      .eq('id', validatedData.servicoId)
      .single()

    const duration = service?.duracao_minutos || 60

    // Create proposed time slot
    const startTime = new Date(validatedData.dataHora)
    const endTime = new Date(startTime.getTime() + duration * 60000)

    const proposedSlot: TimeSlot = {
      providerId: validatedData.providerId || 'default-provider-id',
      start: startTime,
      end: endTime,
    }

    // Add buffer time (15 minutes)
    const slotWithBuffer = addBufferTime(proposedSlot, 15)

    // Fetch existing appointments for this provider on this date
    const startOfDay = new Date(startTime)
    startOfDay.setHours(0, 0, 0, 0)
    const endOfDay = new Date(startTime)
    endOfDay.setHours(23, 59, 59, 999)

    const { data: existingApts } = await supabase
      .from('agendamentos')
      .select('id, data_hora, servicos(duracao_minutos)')
      .eq('provider_id', slotWithBuffer.providerId)
      .gte('data_hora', startOfDay.toISOString())
      .lte('data_hora', endOfDay.toISOString())
      .neq('status', 'CANCELADO')  // Ignore cancelled appointments

    // Convert to TimeSlot format
    const existingSlots: TimeSlot[] = (existingApts || []).map(apt => {
      const start = new Date(apt.data_hora)
      const duration = (apt.servicos as any)?.duracao_minutos || 60
      const end = new Date(start.getTime() + duration * 60000)

      return {
        id: apt.id,
        providerId: slotWithBuffer.providerId,
        start,
        end,
      }
    })

    // Check for conflicts
    const conflicts = findConflicts(slotWithBuffer, existingSlots)

    if (conflicts.length > 0) {
      return NextResponse.json(
        {
          error: 'Conflito de horário detectado',
          conflicts: conflicts.map(c => c.id),
        },
        { status: 409 }  // Conflict status code
      )
    }

    // No conflicts - proceed with insert
    const { data, error } = await supabase
      .from('agendamentos')
      .insert({
        paciente_id: validatedData.pacienteId,
        servico_id: validatedData.servicoId,
        provider_id: validatedData.providerId || 'default-provider-id',
        data_hora: validatedData.dataHora,
        observacoes: validatedData.observacoes,
        status: validatedData.status,
        criado_por: user.id,
      })
      .select()
      .single()

    if (error) throw error

    // ... existing audit logging

    return NextResponse.json(data, { status: 201 })
  } catch (error) {
    // ... existing error handling
  }
}
```

**Acceptance:**
- Fetches existing appointments for conflict check
- Calculates proposed slot duration from service
- Adds buffer time to proposed slot
- Returns 409 Conflict if overlap detected
- Insert only proceeds if no conflicts

### Task 4: Add conflict validation to update appointment API

Modify `src/app/api/agendamentos/[id]/route.ts` PUT endpoint:

Similar conflict check logic as POST, but:
- Include appointment ID in proposedSlot for self-exclusion
- Only check conflicts if dataHora or providerId changed
- Fetch original appointment data to compare

```typescript
export async function PUT(
  req: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    // ... existing auth and validation

    const { id } = await params
    const validatedData = updateAppointmentSchema.parse(body)
    const supabase = await createServerClient()

    // Fetch original appointment
    const { data: original } = await supabase
      .from('agendamentos')
      .select('data_hora, provider_id, servico_id')
      .eq('id', id)
      .single()

    if (!original) {
      return NextResponse.json({ error: 'Appointment not found' }, { status: 404 })
    }

    // Only check conflicts if time or provider changed
    const timeChanged = validatedData.dataHora && validatedData.dataHora !== original.data_hora
    const providerChanged = validatedData.providerId && validatedData.providerId !== original.provider_id

    if (timeChanged || providerChanged) {
      // Fetch service duration
      const servicoId = validatedData.servicoId || original.servico_id
      const { data: service } = await supabase
        .from('servicos')
        .select('duracao_minutos')
        .eq('id', servicoId)
        .single()

      const duration = service?.duracao_minutos || 60

      // Create proposed slot
      const startTime = new Date(validatedData.dataHora || original.data_hora)
      const endTime = new Date(startTime.getTime() + duration * 60000)

      const proposedSlot: TimeSlot = {
        id,  // Include ID for self-exclusion
        providerId: validatedData.providerId || original.provider_id,
        start: startTime,
        end: endTime,
      }

      const slotWithBuffer = addBufferTime(proposedSlot, 15)

      // Fetch existing appointments (same logic as POST)
      // ... conflict checking logic

      if (conflicts.length > 0) {
        return NextResponse.json(
          { error: 'Conflito de horário detectado', conflicts: conflicts.map(c => c.id) },
          { status: 409 }
        )
      }
    }

    // No conflicts or no time change - proceed with update
    // ... existing update logic
  } catch (error) {
    // ... existing error handling
  }
}
```

**Acceptance:**
- Conflict check only runs if time/provider changes
- Self-exclusion works (appointment doesn't conflict with itself)
- Returns 409 if conflict detected
- Update proceeds if no conflicts

### Task 5: Show conflict warnings in appointment modal

Modify `src/components/calendar/appointment-modal.tsx` to show conflicts:

```typescript
const [conflictError, setConflictError] = useState<string | null>(null)

const handleSave = async () => {
  setLoading(true)
  setConflictError(null)  // Clear previous errors

  try {
    const url = appointmentId
      ? `/api/agendamentos/${appointmentId}`
      : '/api/agendamentos'

    const method = appointmentId ? 'PUT' : 'POST'

    const res = await fetch(url, {
      method,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(formData),
    })

    if (!res.ok) {
      const error = await res.json()

      // Handle conflict error specially
      if (res.status === 409) {
        setConflictError('Conflito de horário: já existe um agendamento neste horário para este profissional.')
        toast.error('Horário indisponível')
        return  // Don't close modal
      }

      throw new Error(error.error || 'Erro ao salvar agendamento')
    }

    toast.success(appointmentId ? 'Agendamento atualizado' : 'Agendamento criado')
    onSave()
    onClose()
  } catch (error) {
    toast.error(error instanceof Error ? error.message : 'Erro ao salvar')
  } finally {
    setLoading(false)
  }
}

// Add conflict warning in modal UI
{conflictError && (
  <div className="p-3 bg-red-50 border border-red-200 rounded-md">
    <p className="text-sm text-red-600">{conflictError}</p>
  </div>
)}
```

**Acceptance:**
- Conflict errors displayed in modal (don't close modal)
- User can adjust time and retry
- Toast notification shows conflict
- Success closes modal as normal
</tasks>

<verification>
**Manual testing checklist:**

1. Conflict detection - same provider
   - [ ] Create appointment at 10:00-11:00 for Provider A
   - [ ] Try to create appointment at 10:30-11:30 for Provider A → conflict error
   - [ ] Try to create appointment at 11:00-12:00 for Provider A → conflict (buffer time)
   - [ ] Try to create appointment at 11:15-12:15 for Provider A → success (buffer cleared)

2. Conflict detection - different providers
   - [ ] Create appointment at 10:00-11:00 for Provider A
   - [ ] Create appointment at 10:00-11:00 for Provider B → success (no conflict)

3. Buffer time enforcement
   - [ ] Appointment at 10:00-11:00
   - [ ] Try appointment at 11:00-12:00 → conflict (needs 15 min buffer)
   - [ ] Appointment at 11:15-12:15 → success

4. Update validation
   - [ ] Edit existing appointment to conflict time → error
   - [ ] Edit to non-conflicting time → success
   - [ ] Edit without changing time → success (no conflict check)

5. Visual feedback
   - [ ] Conflict error shows in modal
   - [ ] Error message clear and actionable
   - [ ] Modal stays open on conflict (allows retry)

6. Edge cases
   - [ ] Cancelled appointments don't block slots
   - [ ] Updating appointment doesn't conflict with itself
   - [ ] All-day events handled correctly (if supported)

**Automated checks:**
- Unit tests for hasOverlap function
- Unit tests for findConflicts with various scenarios
- API returns 409 status code for conflicts
</verification>

<success_criteria>
- [ ] System prevents double-booking same provider at same time
- [ ] 15-minute buffer time enforced between appointments
- [ ] Conflict validation runs server-side before INSERT/UPDATE
- [ ] User sees clear error message when conflict detected
- [ ] Modal stays open on conflict (allows user to adjust time)
- [ ] Different providers can have same time slots (no conflict)
- [ ] Cancelled appointments don't block time slots
- [ ] Update appointment doesn't conflict with itself
</success_criteria>

<output>
**Created files:**
- src/lib/calendar/conflict-detection.ts - Interval overlap algorithm (O(n log n))
- src/lib/calendar/availability-calculator.ts - Available slot calculation with buffer times

**Modified files:**
- src/app/api/agendamentos/route.ts - Added conflict validation to POST
- src/app/api/agendamentos/[id]/route.ts - Added conflict validation to PUT
- src/components/calendar/appointment-modal.tsx - Display conflict errors

**Next steps:**
- Plan 05: Waitlist Management (auto-fill cancelled slots, priority queue)
- Plan 06: N8N Integration and Time Zones (sync with workflows, DST handling)
</output>
