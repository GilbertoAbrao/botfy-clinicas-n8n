---
phase: 04-calendar-scheduling
plan: 02
wave: 2
depends_on: [04-01]
subsystem: calendar
tags: [appointment-crud, calendar-modal, zod-validation, audit-logging]

files_modified:
  - src/components/calendar/appointment-modal.tsx (create)
  - src/lib/validations/appointment.ts (create)
  - src/app/api/agendamentos/route.ts (create)
  - src/app/api/agendamentos/[id]/route.ts (create)
  - src/components/calendar/calendar-view.tsx (modify)
  - src/hooks/use-calendar-events.ts (modify)

autonomous: true

must_haves:
  truths:
    - "User can click time slot to create new appointment"
    - "User can click existing appointment to view/edit details"
    - "User can delete appointment with confirmation dialog"
    - "User can reschedule appointment by changing date/time"
    - "All appointment operations are audit-logged"
  artifacts:
    - "src/components/calendar/appointment-modal.tsx handles create/edit/delete"
    - "src/app/api/agendamentos/route.ts handles POST (create)"
    - "src/app/api/agendamentos/[id]/route.ts handles PUT (update) and DELETE"
    - "src/lib/validations/appointment.ts has Zod schemas for validation"
  key_links:
    - "Click empty slot → modal opens to create appointment"
    - "Click appointment → modal opens with edit/delete options"
---

# Phase 4 Plan 2: Appointment CRUD Operations

**Enable creating, editing, and deleting appointments directly from the calendar interface with modal dialogs and server-side validation**

<objective>
Implement full CRUD (Create, Read, Update, Delete) functionality for appointments. Users can click calendar time slots to create new appointments, click existing appointments to edit or delete them. All operations validated server-side with Zod schemas and audit-logged for HIPAA compliance.
</objective>

<execution_context>
**Framework references:**
@~/.claude/get-shit-done/references/principles.md
@~/.claude/get-shit-done/references/plan-format.md

**Research context:**
@.planning/phases/04-calendar-scheduling/04-RESEARCH.md

**Key research findings:**
- Use Zod for appointment validation (time slots, conflicts)
- Modal dialogs for appointment forms (Schedule-X compatible)
- Audit log all CRUD operations for HIPAA compliance
</execution_context>

<context>
**Project state:**
@.planning/STATE.md
@.planning/ROADMAP.md

**Prior work:**
- Plan 04-01 completed: Calendar views with Schedule-X, timezone utilities
- Phase 3: Patient management with CRUD APIs and audit logging patterns
- Phase 1: Audit logging infrastructure with logAudit() function

**Requirements addressed:**
- CAL-05: Create new appointment manually
- CAL-06: Edit existing appointment
- CAL-08: Cancel appointment
- CAL-09: View appointment details

**Tech stack:**
- Next.js API routes for backend
- Zod for validation
- Supabase for data persistence
- Audit logging from Phase 1
- Modal dialogs with shadcn/ui
</context>

<tasks>
### Task 1: Create appointment validation schemas

Create `src/lib/validations/appointment.ts` with Zod schemas:

```typescript
import { z } from 'zod'

// Create appointment schema
export const createAppointmentSchema = z.object({
  pacienteId: z.string().uuid({ message: 'ID do paciente inválido' }),
  servicoId: z.string().uuid({ message: 'ID do serviço inválido' }),
  dataHora: z.string().datetime({ message: 'Data e hora inválidas' }),
  observacoes: z.string().optional(),
  status: z.enum(['AGENDADO', 'CONFIRMADO', 'REALIZADO', 'CANCELADO', 'FALTOU']).default('AGENDADO'),
})

// Update appointment schema (all fields optional for partial updates)
export const updateAppointmentSchema = z.object({
  pacienteId: z.string().uuid().optional(),
  servicoId: z.string().uuid().optional(),
  dataHora: z.string().datetime().optional(),
  observacoes: z.string().optional(),
  status: z.enum(['AGENDADO', 'CONFIRMADO', 'REALIZADO', 'CANCELADO', 'FALTOU']).optional(),
})

export type CreateAppointmentInput = z.infer<typeof createAppointmentSchema>
export type UpdateAppointmentInput = z.infer<typeof updateAppointmentSchema>
```

**Acceptance:**
- Schemas validate required fields for create
- Optional fields allowed for update
- Exports TypeScript types from schemas

### Task 2: Create appointment API endpoints

Create `src/app/api/agendamentos/route.ts` for creating appointments:

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { getCurrentUserWithRole } from '@/lib/auth/session'
import { createServerClient } from '@/lib/supabase/server'
import { createAppointmentSchema } from '@/lib/validations/appointment'
import { logAudit, AuditAction } from '@/lib/audit/logger'

export async function POST(req: NextRequest) {
  try {
    // Check authentication and authorization
    const user = await getCurrentUserWithRole()
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Only ADMIN and ATENDENTE can create appointments
    if (!['ADMIN', 'ATENDENTE'].includes(user.role)) {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
    }

    // Parse and validate request body
    const body = await req.json()
    const validatedData = createAppointmentSchema.parse(body)

    const supabase = await createServerClient()

    // Insert appointment
    const { data, error } = await supabase
      .from('agendamentos')
      .insert({
        paciente_id: validatedData.pacienteId,
        servico_id: validatedData.servicoId,
        data_hora: validatedData.dataHora,
        observacoes: validatedData.observacoes,
        status: validatedData.status,
        criado_por: user.id,
      })
      .select()
      .single()

    if (error) throw error

    // Audit log
    await logAudit({
      userId: user.id,
      action: AuditAction.CREATE_APPOINTMENT,
      resource: 'agendamentos',
      resourceId: data.id,
      details: {
        pacienteId: validatedData.pacienteId,
        servicoId: validatedData.servicoId,
        dataHora: validatedData.dataHora,
      },
    })

    return NextResponse.json(data, { status: 201 })
  } catch (error) {
    console.error('Error creating appointment:', error)
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Internal server error' },
      { status: 500 }
    )
  }
}
```

Create `src/app/api/agendamentos/[id]/route.ts` for update and delete:

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { getCurrentUserWithRole } from '@/lib/auth/session'
import { createServerClient } from '@/lib/supabase/server'
import { updateAppointmentSchema } from '@/lib/validations/appointment'
import { logAudit, AuditAction } from '@/lib/audit/logger'

export async function PUT(
  req: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const user = await getCurrentUserWithRole()
    if (!user || !['ADMIN', 'ATENDENTE'].includes(user.role)) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { id } = await params
    const body = await req.json()
    const validatedData = updateAppointmentSchema.parse(body)

    const supabase = await createServerClient()

    // Update appointment
    const updateData: any = {}
    if (validatedData.pacienteId) updateData.paciente_id = validatedData.pacienteId
    if (validatedData.servicoId) updateData.servico_id = validatedData.servicoId
    if (validatedData.dataHora) updateData.data_hora = validatedData.dataHora
    if (validatedData.observacoes !== undefined) updateData.observacoes = validatedData.observacoes
    if (validatedData.status) updateData.status = validatedData.status

    const { data, error } = await supabase
      .from('agendamentos')
      .update(updateData)
      .eq('id', id)
      .select()
      .single()

    if (error) throw error

    // Audit log
    await logAudit({
      userId: user.id,
      action: AuditAction.UPDATE_APPOINTMENT,
      resource: 'agendamentos',
      resourceId: id,
      details: validatedData,
    })

    return NextResponse.json(data)
  } catch (error) {
    console.error('Error updating appointment:', error)
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Internal server error' },
      { status: 500 }
    )
  }
}

export async function DELETE(
  req: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const user = await getCurrentUserWithRole()
    if (!user || !['ADMIN', 'ATENDENTE'].includes(user.role)) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { id } = await params
    const supabase = await createServerClient()

    // Delete appointment
    const { error } = await supabase
      .from('agendamentos')
      .delete()
      .eq('id', id)

    if (error) throw error

    // Audit log
    await logAudit({
      userId: user.id,
      action: AuditAction.DELETE_APPOINTMENT,
      resource: 'agendamentos',
      resourceId: id,
    })

    return NextResponse.json({ success: true })
  } catch (error) {
    console.error('Error deleting appointment:', error)
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Internal server error' },
      { status: 500 }
    )
  }
}
```

**Acceptance:**
- POST /api/agendamentos creates appointment
- PUT /api/agendamentos/[id] updates appointment
- DELETE /api/agendamentos/[id] deletes appointment
- All endpoints require ADMIN or ATENDENTE role
- All operations audit-logged

### Task 3: Create appointment modal component

Create `src/components/calendar/appointment-modal.tsx`:

```typescript
'use client'

import { useState, useEffect } from 'react'
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from '@/components/ui/dialog'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
import { Textarea } from '@/components/ui/textarea'
import { toast } from 'sonner'
import { Trash2 } from 'lucide-react'
import { createBrowserClient } from '@/lib/supabase/client'

interface AppointmentModalProps {
  isOpen: boolean
  onClose: () => void
  onSave: () => void
  appointmentId?: string  // undefined = create mode, string = edit mode
  initialData?: {
    pacienteId: string
    servicoId: string
    dataHora: string
    observacoes?: string
    status?: string
  }
}

export function AppointmentModal({
  isOpen,
  onClose,
  onSave,
  appointmentId,
  initialData,
}: AppointmentModalProps) {
  const [loading, setLoading] = useState(false)
  const [patients, setPatients] = useState<any[]>([])
  const [services, setServices] = useState<any[]>([])
  const [formData, setFormData] = useState({
    pacienteId: initialData?.pacienteId || '',
    servicoId: initialData?.servicoId || '',
    dataHora: initialData?.dataHora || '',
    observacoes: initialData?.observacoes || '',
    status: initialData?.status || 'AGENDADO',
  })

  // Fetch patients and services on mount
  useEffect(() => {
    const fetchData = async () => {
      const supabase = createBrowserClient()

      const [patientsRes, servicesRes] = await Promise.all([
        supabase.from('pacientes').select('id, nome').order('nome'),
        supabase.from('servicos').select('id, nome').eq('ativo', true).order('nome'),
      ])

      if (patientsRes.data) setPatients(patientsRes.data)
      if (servicesRes.data) setServices(servicesRes.data)
    }

    if (isOpen) {
      fetchData()
    }
  }, [isOpen])

  const handleSave = async () => {
    setLoading(true)

    try {
      const url = appointmentId
        ? `/api/agendamentos/${appointmentId}`
        : '/api/agendamentos'

      const method = appointmentId ? 'PUT' : 'POST'

      const res = await fetch(url, {
        method,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(formData),
      })

      if (!res.ok) {
        const error = await res.json()
        throw new Error(error.error || 'Erro ao salvar agendamento')
      }

      toast.success(appointmentId ? 'Agendamento atualizado' : 'Agendamento criado')
      onSave()
      onClose()
    } catch (error) {
      toast.error(error instanceof Error ? error.message : 'Erro ao salvar')
    } finally {
      setLoading(false)
    }
  }

  const handleDelete = async () => {
    if (!appointmentId) return
    if (!confirm('Tem certeza que deseja cancelar este agendamento?')) return

    setLoading(true)

    try {
      const res = await fetch(`/api/agendamentos/${appointmentId}`, {
        method: 'DELETE',
      })

      if (!res.ok) throw new Error('Erro ao cancelar agendamento')

      toast.success('Agendamento cancelado')
      onSave()
      onClose()
    } catch (error) {
      toast.error(error instanceof Error ? error.message : 'Erro ao cancelar')
    } finally {
      setLoading(false)
    }
  }

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-md">
        <DialogHeader>
          <DialogTitle>
            {appointmentId ? 'Editar Agendamento' : 'Novo Agendamento'}
          </DialogTitle>
        </DialogHeader>

        <div className="space-y-4">
          {/* Patient select */}
          <div>
            <Label>Paciente</Label>
            <Select
              value={formData.pacienteId}
              onValueChange={(value) => setFormData({ ...formData, pacienteId: value })}
            >
              <SelectTrigger>
                <SelectValue placeholder="Selecione o paciente" />
              </SelectTrigger>
              <SelectContent>
                {patients.map((p) => (
                  <SelectItem key={p.id} value={p.id}>
                    {p.nome}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          {/* Service select */}
          <div>
            <Label>Serviço</Label>
            <Select
              value={formData.servicoId}
              onValueChange={(value) => setFormData({ ...formData, servicoId: value })}
            >
              <SelectTrigger>
                <SelectValue placeholder="Selecione o serviço" />
              </SelectTrigger>
              <SelectContent>
                {services.map((s) => (
                  <SelectItem key={s.id} value={s.id}>
                    {s.nome}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          {/* Date and time */}
          <div>
            <Label>Data e Hora</Label>
            <Input
              type="datetime-local"
              value={formData.dataHora}
              onChange={(e) => setFormData({ ...formData, dataHora: e.target.value })}
            />
          </div>

          {/* Status (edit mode only) */}
          {appointmentId && (
            <div>
              <Label>Status</Label>
              <Select
                value={formData.status}
                onValueChange={(value) => setFormData({ ...formData, status: value })}
              >
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="AGENDADO">Agendado</SelectItem>
                  <SelectItem value="CONFIRMADO">Confirmado</SelectItem>
                  <SelectItem value="REALIZADO">Realizado</SelectItem>
                  <SelectItem value="CANCELADO">Cancelado</SelectItem>
                  <SelectItem value="FALTOU">Faltou</SelectItem>
                </SelectContent>
              </Select>
            </div>
          )}

          {/* Observations */}
          <div>
            <Label>Observações</Label>
            <Textarea
              value={formData.observacoes}
              onChange={(e) => setFormData({ ...formData, observacoes: e.target.value })}
              placeholder="Observações adicionais (opcional)"
              rows={3}
            />
          </div>
        </div>

        <DialogFooter className="flex justify-between">
          {/* Delete button (edit mode only) */}
          {appointmentId && (
            <Button
              type="button"
              variant="destructive"
              onClick={handleDelete}
              disabled={loading}
            >
              <Trash2 className="h-4 w-4 mr-2" />
              Cancelar Agendamento
            </Button>
          )}

          <div className="flex gap-2 ml-auto">
            <Button type="button" variant="outline" onClick={onClose}>
              Fechar
            </Button>
            <Button onClick={handleSave} disabled={loading}>
              {loading ? 'Salvando...' : 'Salvar'}
            </Button>
          </div>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  )
}
```

**Acceptance:**
- Modal shows create form when appointmentId is undefined
- Modal shows edit form with delete button when appointmentId provided
- Patient and service dropdowns populated from database
- Datetime-local input for date/time selection
- Status select only visible in edit mode

### Task 4: Integrate modal with calendar component

Modify `src/components/calendar/calendar-view.tsx` to open modal on click:

Add state and handlers:
```typescript
const [modalOpen, setModalOpen] = useState(false)
const [selectedAppointment, setSelectedAppointment] = useState<string | undefined>()
const [initialModalData, setInitialModalData] = useState<any>()
```

Add click handlers to calendar config:
```typescript
const calendar = createCalendar({
  // ... existing config
  callbacks: {
    onEventClick(calendarEvent) {
      // Open modal in edit mode
      setSelectedAppointment(calendarEvent.id)
      setInitialModalData({
        pacienteId: events.find(e => e.id === calendarEvent.id)?.patientId || '',
        servicoId: events.find(e => e.id === calendarEvent.id)?.serviceId || '',
        dataHora: calendarEvent.start,
        status: events.find(e => e.id === calendarEvent.id)?.status,
      })
      setModalOpen(true)
    },
    onClickDateTime(dateTime) {
      // Open modal in create mode
      setSelectedAppointment(undefined)
      setInitialModalData({
        pacienteId: '',
        servicoId: '',
        dataHora: dateTime,
      })
      setModalOpen(true)
    },
  },
})
```

Add modal component at end of CalendarView return:
```tsx
<AppointmentModal
  isOpen={modalOpen}
  onClose={() => setModalOpen(false)}
  onSave={() => {
    setModalOpen(false)
    // Trigger refetch of events
    // (hook will refetch automatically on dependency change)
  }}
  appointmentId={selectedAppointment}
  initialData={initialModalData}
/>
```

**Acceptance:**
- Click empty slot → modal opens in create mode
- Click existing event → modal opens in edit mode with data
- Save in modal → refetches calendar events

### Task 5: Add refetch capability to calendar hook

Modify `src/hooks/use-calendar-events.ts` to support manual refetch:

Add refetch function:
```typescript
const refetch = useCallback(() => {
  fetchEvents()
}, [startDate, endDate])

return { events, loading, error, refetch }
```

**Acceptance:**
- Hook exposes refetch function
- Calling refetch reloads events from database
- Calendar refreshes after create/edit/delete operations
</tasks>

<verification>
**Manual testing checklist:**

1. Create appointment
   - [ ] Click empty calendar slot
   - [ ] Modal opens with empty form
   - [ ] Fill patient, service, date/time
   - [ ] Click "Salvar"
   - [ ] Appointment appears on calendar
   - [ ] Success toast shows

2. Edit appointment
   - [ ] Click existing appointment on calendar
   - [ ] Modal opens with appointment data pre-filled
   - [ ] Change date/time or status
   - [ ] Click "Salvar"
   - [ ] Appointment updates on calendar
   - [ ] Success toast shows

3. Delete appointment
   - [ ] Click existing appointment
   - [ ] Click "Cancelar Agendamento" button
   - [ ] Confirmation dialog appears
   - [ ] Confirm deletion
   - [ ] Appointment removed from calendar
   - [ ] Success toast shows

4. Validation
   - [ ] Try to save without patient → validation error
   - [ ] Try to save without service → validation error
   - [ ] Invalid datetime rejected

5. Audit logging
   - [ ] Check audit_logs table has CREATE_APPOINTMENT entry
   - [ ] Check UPDATE_APPOINTMENT entry after edit
   - [ ] Check DELETE_APPOINTMENT entry after delete

**Automated checks:**
- API endpoints return correct status codes
- Validation schemas catch invalid input
- Database constraints enforced
</verification>

<success_criteria>
- [ ] User can create appointment by clicking calendar slot
- [ ] User can edit appointment by clicking existing event
- [ ] User can delete appointment with confirmation
- [ ] All CRUD operations validated server-side with Zod
- [ ] All operations audit-logged with userId and details
- [ ] Calendar refreshes automatically after save/delete
- [ ] Only ADMIN and ATENDENTE can perform CRUD operations
- [ ] No TypeScript errors or build warnings
</success_criteria>

<output>
**Created files:**
- src/lib/validations/appointment.ts - Zod schemas for appointment validation
- src/app/api/agendamentos/route.ts - POST endpoint for creating appointments
- src/app/api/agendamentos/[id]/route.ts - PUT and DELETE endpoints
- src/components/calendar/appointment-modal.tsx - Modal dialog for CRUD operations

**Modified files:**
- src/components/calendar/calendar-view.tsx - Added click handlers and modal integration
- src/hooks/use-calendar-events.ts - Added refetch capability

**Next steps:**
- Plan 03: Multi-Provider Support and Filtering (CAL-02, CAL-10, CAL-11)
- Plan 04: Conflict Detection and Availability (CAL-04, time slot validation)
</output>
