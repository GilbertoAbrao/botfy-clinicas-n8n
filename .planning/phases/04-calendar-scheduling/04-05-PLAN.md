---
phase: 04-calendar-scheduling
plan: 05
wave: 3
depends_on: [04-02, 04-04]
subsystem: calendar
tags: [waitlist, auto-fill, queue-management, notifications]

files_modified:
  - prisma/schema.prisma (modify - add Waitlist model)
  - src/app/api/waitlist/route.ts (create)
  - src/app/api/waitlist/[id]/route.ts (create)
  - src/components/calendar/waitlist-manager.tsx (create)
  - src/lib/waitlist/auto-fill.ts (create)
  - src/app/agenda/page.tsx (modify)

autonomous: true

must_haves:
  truths:
    - "User can add patient to waitlist for earlier appointment"
    - "Waitlist shows priority (urgent vs convenience)"
    - "Cancelled appointment automatically notifies waitlist"
    - "Waitlist entries removed after appointment rescheduled"
    - "System prevents duplicate waitlist entries"
  artifacts:
    - "prisma/schema.prisma has Waitlist model"
    - "src/lib/waitlist/auto-fill.ts triggers on cancellation"
    - "src/components/calendar/waitlist-manager.tsx displays queue"
  key_links:
    - "Cancel appointment → waitlist receives notification"
    - "/agenda page shows waitlist panel with priority queue"
---

# Phase 4 Plan 5: Waitlist Management

**Implement waitlist functionality with priority queue, automatic notifications when slots become available, and waitlist management UI**

<objective>
Build waitlist system to capture patients wanting earlier appointments. When appointments are cancelled, automatically notify waitlist entries in priority order (urgent before convenience). Provides better patient experience and reduces empty slots from cancellations.
</objective>

<execution_context>
**Framework references:**
@~/.claude/get-shit-done/references/principles.md

**Research context:**
@.planning/phases/04-calendar-scheduling/04-RESEARCH.md

**Key research findings:**
- Automated waitlist systems reduce empty slots by 15-20%
- Priority queue: urgent cases before convenience requests
- Instant notifications improve acceptance rate
- Research shows manual waitlist calls often forgotten (Pitfall 6 from research)
</execution_context>

<context>
**Project state:**
@.planning/STATE.md

**Prior work:**
- Plan 04-02: Appointment CRUD with delete functionality
- Plan 04-04: Conflict detection and availability calculation
- Phase 1: Audit logging infrastructure

**Requirements addressed:**
- CAL-12: System manages waitlist
- CAL-13: System automatically fills cancelled appointments from waitlist
- CAL-14: User can add patient to waitlist

**Waitlist strategy:**
- Priority levels: URGENT (medical need) and CONVENIENCE (prefer earlier time)
- Notification via N8N workflow (leverage existing WhatsApp integration)
- Expiry: Remove waitlist entry after 7 days if not filled
</context>

<tasks>
### Task 1: Add Waitlist model to Prisma schema

Add to `prisma/schema.prisma`:

```prisma
model Waitlist {
  id            String   @id @default(uuid())
  paciente_id   String
  servico_id    String
  provider_id   String?  // Specific provider preference (optional)
  priority      String   @default("CONVENIENCE")  // URGENT or CONVENIENCE
  preferred_date DateTime?  // Preferred date/time (optional)
  notes         String?
  status        String   @default("ACTIVE")  // ACTIVE, NOTIFIED, FILLED, EXPIRED
  created_at    DateTime @default(now())
  expires_at    DateTime  // Auto-set to 7 days from creation
  created_by    String

  paciente Patient   @relation("WaitlistPatient", fields: [paciente_id], references: [id], onDelete: Cascade)
  servico  Service   @relation("WaitlistService", fields: [servico_id], references: [id])
  provider Provider? @relation("WaitlistProvider", fields: [provider_id], references: [id])
  criador  User      @relation("WaitlistCreator", fields: [created_by], references: [id])

  @@map("waitlist")
  @@index([status, priority, created_at])  // For priority queue queries
  @@index([paciente_id, servico_id])  // Prevent duplicates
}
```

Add relations to existing models:

```prisma
model Patient {
  // ... existing fields
  waitlistEntries Waitlist[] @relation("WaitlistPatient")
}

model Service {
  // ... existing fields
  waitlistEntries Waitlist[] @relation("WaitlistService")
}

model Provider {
  // ... existing fields
  waitlistEntries Waitlist[] @relation("WaitlistProvider")
}

model User {
  // ... existing fields
  waitlistCreations Waitlist[] @relation("WaitlistCreator")
}
```

Run migration:
```bash
npx prisma migrate dev --name add_waitlist_table
npx prisma generate
```

**Acceptance:**
- Waitlist table created with all fields
- Relations to Patient, Service, Provider, User
- Index on status+priority for efficient queue queries
- Cascade delete when patient removed

### Task 2: Create waitlist API endpoints

Create `src/app/api/waitlist/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { getCurrentUserWithRole } from '@/lib/auth/session'
import { createServerClient } from '@/lib/supabase/server'
import { logAudit, AuditAction } from '@/lib/audit/logger'
import { z } from 'zod'

const createWaitlistSchema = z.object({
  pacienteId: z.string().uuid(),
  servicoId: z.string().uuid(),
  providerId: z.string().uuid().optional(),
  priority: z.enum(['URGENT', 'CONVENIENCE']).default('CONVENIENCE'),
  preferredDate: z.string().datetime().optional(),
  notes: z.string().optional(),
})

// GET: List waitlist entries (priority queue)
export async function GET(req: NextRequest) {
  try {
    const user = await getCurrentUserWithRole()
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const supabase = await createServerClient()

    // Query waitlist ordered by priority (URGENT first), then creation date
    const { data, error } = await supabase
      .from('waitlist')
      .select(`
        *,
        paciente:pacientes(id, nome, telefone),
        servico:servicos(id, nome),
        provider:providers(id, nome)
      `)
      .eq('status', 'ACTIVE')
      .order('priority', { ascending: false })  // URGENT before CONVENIENCE
      .order('created_at', { ascending: true })  // FIFO within priority

    if (error) throw error

    return NextResponse.json(data || [])
  } catch (error) {
    console.error('Error fetching waitlist:', error)
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Internal server error' },
      { status: 500 }
    )
  }
}

// POST: Add to waitlist
export async function POST(req: NextRequest) {
  try {
    const user = await getCurrentUserWithRole()
    if (!user || !['ADMIN', 'ATENDENTE'].includes(user.role)) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await req.json()
    const validatedData = createWaitlistSchema.parse(body)

    const supabase = await createServerClient()

    // Check for duplicate entry (same patient + service + ACTIVE status)
    const { data: existing } = await supabase
      .from('waitlist')
      .select('id')
      .eq('paciente_id', validatedData.pacienteId)
      .eq('servico_id', validatedData.servicoId)
      .eq('status', 'ACTIVE')
      .single()

    if (existing) {
      return NextResponse.json(
        { error: 'Paciente já está na lista de espera para este serviço' },
        { status: 409 }
      )
    }

    // Calculate expiry date (7 days from now)
    const expiresAt = new Date()
    expiresAt.setDate(expiresAt.getDate() + 7)

    // Insert waitlist entry
    const { data, error } = await supabase
      .from('waitlist')
      .insert({
        paciente_id: validatedData.pacienteId,
        servico_id: validatedData.servicoId,
        provider_id: validatedData.providerId,
        priority: validatedData.priority,
        preferred_date: validatedData.preferredDate,
        notes: validatedData.notes,
        status: 'ACTIVE',
        expires_at: expiresAt.toISOString(),
        created_by: user.id,
      })
      .select()
      .single()

    if (error) throw error

    // Audit log
    await logAudit({
      userId: user.id,
      action: AuditAction.ADD_WAITLIST,
      resource: 'waitlist',
      resourceId: data.id,
      details: validatedData,
    })

    return NextResponse.json(data, { status: 201 })
  } catch (error) {
    console.error('Error adding to waitlist:', error)
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Internal server error' },
      { status: 500 }
    )
  }
}
```

Create `src/app/api/waitlist/[id]/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { getCurrentUserWithRole } from '@/lib/auth/session'
import { createServerClient } from '@/lib/supabase/server'
import { logAudit, AuditAction } from '@/lib/audit/logger'

// DELETE: Remove from waitlist
export async function DELETE(
  req: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const user = await getCurrentUserWithRole()
    if (!user || !['ADMIN', 'ATENDENTE'].includes(user.role)) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { id } = await params
    const supabase = await createServerClient()

    // Delete waitlist entry
    const { error } = await supabase
      .from('waitlist')
      .delete()
      .eq('id', id)

    if (error) throw error

    // Audit log
    await logAudit({
      userId: user.id,
      action: AuditAction.REMOVE_WAITLIST,
      resource: 'waitlist',
      resourceId: id,
    })

    return NextResponse.json({ success: true })
  } catch (error) {
    console.error('Error removing from waitlist:', error)
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Internal server error' },
      { status: 500 }
    )
  }
}

// PUT: Update waitlist status (for auto-fill process)
export async function PUT(
  req: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const user = await getCurrentUserWithRole()
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { id } = await params
    const { status } = await req.json()

    const supabase = await createServerClient()

    const { data, error } = await supabase
      .from('waitlist')
      .update({ status })
      .eq('id', id)
      .select()
      .single()

    if (error) throw error

    return NextResponse.json(data)
  } catch (error) {
    console.error('Error updating waitlist:', error)
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Internal server error' },
      { status: 500 }
    )
  }
}
```

**Acceptance:**
- GET /api/waitlist returns priority queue (URGENT first, FIFO within priority)
- POST /api/waitlist adds entry with 7-day expiry
- DELETE /api/waitlist/[id] removes entry
- PUT /api/waitlist/[id] updates status
- Duplicate check prevents same patient+service twice

### Task 3: Create auto-fill logic for cancelled appointments

Create `src/lib/waitlist/auto-fill.ts`:

```typescript
import { createServerClient } from '@/lib/supabase/server'

/**
 * Notify waitlist when appointment slot becomes available
 * Called when appointment is cancelled or rescheduled
 */
export async function notifyWaitlist(
  cancelledAppointment: {
    servicoId: string
    providerId: string
    dataHora: Date
  }
) {
  try {
    const supabase = await createServerClient()

    // Find waitlist entries for this service (prioritized)
    const { data: waitlistEntries } = await supabase
      .from('waitlist')
      .select(`
        *,
        paciente:pacientes(id, nome, telefone)
      `)
      .eq('servico_id', cancelledAppointment.servicoId)
      .eq('status', 'ACTIVE')
      .or(`provider_id.is.null,provider_id.eq.${cancelledAppointment.providerId}`)  // Specific provider or any
      .order('priority', { ascending: false })  // URGENT first
      .order('created_at', { ascending: true })  // FIFO
      .limit(5)  // Notify top 5 candidates

    if (!waitlistEntries || waitlistEntries.length === 0) {
      console.log('No active waitlist entries for cancelled slot')
      return
    }

    // Trigger N8N workflow to send WhatsApp notifications
    for (const entry of waitlistEntries) {
      try {
        // Call N8N webhook to send WhatsApp message
        await fetch(process.env.N8N_WEBHOOK_WAITLIST_NOTIFY || '', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            patientPhone: entry.paciente.telefone,
            patientName: entry.paciente.nome,
            availableSlot: cancelledAppointment.dataHora,
            serviceName: entry.servico.nome,
            waitlistId: entry.id,
          }),
        })

        // Update waitlist status to NOTIFIED
        await supabase
          .from('waitlist')
          .update({ status: 'NOTIFIED' })
          .eq('id', entry.id)

        console.log(`Waitlist notification sent to ${entry.paciente.nome}`)
      } catch (error) {
        console.error(`Failed to notify waitlist entry ${entry.id}:`, error)
      }
    }
  } catch (error) {
    console.error('Error in notifyWaitlist:', error)
  }
}
```

**Acceptance:**
- Function finds matching waitlist entries
- Prioritizes URGENT over CONVENIENCE
- FIFO within priority level
- Calls N8N webhook for WhatsApp notification
- Updates status to NOTIFIED

### Task 4: Integrate auto-fill with appointment deletion

Modify `src/app/api/agendamentos/[id]/route.ts` DELETE endpoint:

```typescript
import { notifyWaitlist } from '@/lib/waitlist/auto-fill'

export async function DELETE(
  req: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    // ... existing auth

    const { id } = await params
    const supabase = await createServerClient()

    // Fetch appointment details before deleting
    const { data: appointment } = await supabase
      .from('agendamentos')
      .select('servico_id, provider_id, data_hora')
      .eq('id', id)
      .single()

    // Delete appointment
    const { error } = await supabase
      .from('agendamentos')
      .delete()
      .eq('id', id)

    if (error) throw error

    // Audit log
    await logAudit({
      userId: user.id,
      action: AuditAction.DELETE_APPOINTMENT,
      resource: 'agendamentos',
      resourceId: id,
    })

    // Trigger waitlist notification (async, don't wait)
    if (appointment) {
      notifyWaitlist({
        servicoId: appointment.servico_id,
        providerId: appointment.provider_id,
        dataHora: new Date(appointment.data_hora),
      }).catch(err => console.error('Waitlist notification failed:', err))
    }

    return NextResponse.json({ success: true })
  } catch (error) {
    // ... existing error handling
  }
}
```

**Acceptance:**
- Deleting appointment triggers waitlist notification
- Notification runs async (doesn't block delete response)
- Error in notification doesn't fail delete operation

### Task 5: Create waitlist manager UI component

Create `src/components/calendar/waitlist-manager.tsx`:

```typescript
'use client'

import { useState, useEffect } from 'react'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { Badge } from '@/components/ui/badge'
import { Clock, User, Trash2 } from 'lucide-react'
import { toast } from 'sonner'
import { format } from 'date-fns'

export function WaitlistManager() {
  const [waitlist, setWaitlist] = useState<any[]>([])
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    fetchWaitlist()
  }, [])

  const fetchWaitlist = async () => {
    setLoading(true)
    try {
      const res = await fetch('/api/waitlist')
      if (!res.ok) throw new Error('Failed to fetch waitlist')

      const data = await res.json()
      setWaitlist(data)
    } catch (error) {
      toast.error('Erro ao carregar lista de espera')
    } finally {
      setLoading(false)
    }
  }

  const handleRemove = async (id: string) => {
    if (!confirm('Remover da lista de espera?')) return

    try {
      const res = await fetch(`/api/waitlist/${id}`, { method: 'DELETE' })
      if (!res.ok) throw new Error('Failed to remove from waitlist')

      toast.success('Removido da lista de espera')
      fetchWaitlist()
    } catch (error) {
      toast.error('Erro ao remover da lista de espera')
    }
  }

  if (loading) {
    return (
      <Card>
        <CardContent className="p-6">
          <p className="text-gray-500">Carregando lista de espera...</p>
        </CardContent>
      </Card>
    )
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <Clock className="h-5 w-5 text-purple-500" />
          Lista de Espera ({waitlist.length})
        </CardTitle>
      </CardHeader>
      <CardContent>
        {waitlist.length === 0 ? (
          <p className="text-gray-500 text-sm">Nenhum paciente na lista de espera</p>
        ) : (
          <div className="space-y-3">
            {waitlist.map((entry) => (
              <div
                key={entry.id}
                className="flex items-center justify-between p-3 border rounded-lg hover:bg-gray-50"
              >
                <div className="flex-1">
                  <div className="flex items-center gap-2">
                    <User className="h-4 w-4 text-gray-400" />
                    <p className="font-medium">{entry.paciente.nome}</p>
                    <Badge
                      variant={entry.priority === 'URGENT' ? 'destructive' : 'secondary'}
                    >
                      {entry.priority === 'URGENT' ? 'Urgente' : 'Conveniência'}
                    </Badge>
                  </div>
                  <p className="text-sm text-gray-600 mt-1">
                    {entry.servico.nome}
                    {entry.provider && ` - ${entry.provider.nome}`}
                  </p>
                  {entry.notes && (
                    <p className="text-xs text-gray-500 mt-1">{entry.notes}</p>
                  )}
                  <p className="text-xs text-gray-400 mt-1">
                    Adicionado em {format(new Date(entry.created_at), 'dd/MM/yyyy HH:mm')}
                  </p>
                </div>

                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => handleRemove(entry.id)}
                >
                  <Trash2 className="h-4 w-4 text-gray-400" />
                </Button>
              </div>
            ))}
          </div>
        )}
      </CardContent>
    </Card>
  )
}
```

**Acceptance:**
- Component displays priority queue
- URGENT entries shown with red badge
- Shows patient name, service, provider preference
- Remove button deletes entry
- Auto-refreshes after removal

### Task 6: Add waitlist panel to agenda page

Modify `src/app/agenda/page.tsx` to show waitlist:

```tsx
import { WaitlistManager } from '@/components/calendar/waitlist-manager'

export default async function AgendaPage() {
  // ... existing code

  return (
    <DashboardLayout>
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* Main calendar (2 columns) */}
        <div className="lg:col-span-2">
          <Card>
            <CardHeader>
              <CardTitle>Calendário de Agendamentos</CardTitle>
            </CardHeader>
            <CardContent>
              <Suspense fallback={<div>Carregando agenda...</div>}>
                <CalendarView />
              </Suspense>
            </CardContent>
          </Card>
        </div>

        {/* Waitlist sidebar (1 column) */}
        <div>
          <WaitlistManager />
        </div>
      </div>
    </DashboardLayout>
  )
}
```

**Acceptance:**
- Waitlist shows in sidebar next to calendar
- Responsive: sidebar moves below calendar on mobile
- Both components load independently
</tasks>

<verification>
**Manual testing checklist:**

1. Add to waitlist
   - [ ] Add patient to waitlist via API
   - [ ] Entry appears in waitlist panel
   - [ ] Priority badge shows correctly (URGENT red, CONVENIENCE gray)
   - [ ] Duplicate entry rejected

2. Priority queue
   - [ ] Add URGENT entry
   - [ ] Add CONVENIENCE entry
   - [ ] URGENT appears first in list
   - [ ] Within priority, FIFO order maintained

3. Auto-fill on cancellation
   - [ ] Cancel appointment
   - [ ] Waitlist entries for that service notified (check logs)
   - [ ] Status updated to NOTIFIED
   - [ ] N8N webhook called (check N8N execution log)

4. Remove from waitlist
   - [ ] Click remove button
   - [ ] Confirmation dialog shows
   - [ ] Entry removed from list
   - [ ] Database record deleted

5. Expiry (manual test)
   - [ ] Create waitlist entry with past expires_at
   - [ ] Entry still shows (expiry cleanup is future feature)

6. Edge cases
   - [ ] No waitlist entries → shows empty state
   - [ ] Waitlist notification fails → doesn't block appointment delete
   - [ ] Patient preference for specific provider respected

**Automated checks:**
- Waitlist table created with correct schema
- API endpoints return correct status codes
- Duplicate prevention works
</verification>

<success_criteria>
- [ ] User can add patient to waitlist with priority level
- [ ] Waitlist displays as priority queue (URGENT first, FIFO within priority)
- [ ] Cancelling appointment triggers waitlist notification
- [ ] Waitlist entries show patient, service, provider preference, notes
- [ ] User can remove entry from waitlist
- [ ] System prevents duplicate waitlist entries
- [ ] N8N webhook integration for WhatsApp notifications
- [ ] Waitlist panel visible on agenda page
</success_criteria>

<output>
**Created files:**
- src/app/api/waitlist/route.ts - GET (list) and POST (add) endpoints
- src/app/api/waitlist/[id]/route.ts - DELETE and PUT endpoints
- src/lib/waitlist/auto-fill.ts - Auto-notification logic
- src/components/calendar/waitlist-manager.tsx - Waitlist UI

**Modified files:**
- prisma/schema.prisma - Added Waitlist model
- src/app/api/agendamentos/[id]/route.ts - Trigger waitlist on delete
- src/app/agenda/page.tsx - Added waitlist sidebar

**Database:**
- Created waitlist table via Prisma migration
- Indexes on status+priority for queue performance

**Next steps:**
- Plan 06: N8N Integration and Time Zones (sync calendar with workflows, DST handling)
</output>
