---
phase: 17-agent-api-foundation
plan: 04
type: execute
wave: 2
depends_on: ["17-01", "17-02"]
files_modified:
  - src/lib/agent/auth.ts
  - src/lib/agent/middleware.ts
  - scripts/generate-agent-key.ts
autonomous: true

must_haves:
  truths:
    - "validateApiKey() compares bearer token against bcrypt hashes in agents table"
    - "validateApiKey() returns AgentContext with correlationId on success"
    - "withAgentAuth() HOF wraps route handlers with authentication"
    - "withAgentAuth() returns 401 for missing/invalid tokens"
    - "generate-agent-key.ts creates secure API key and bcrypt hash"
  artifacts:
    - path: "src/lib/agent/auth.ts"
      provides: "API key validation against database"
      exports: ["validateApiKey"]
    - path: "src/lib/agent/middleware.ts"
      provides: "HOF middleware for agent route authentication"
      exports: ["withAgentAuth"]
    - path: "scripts/generate-agent-key.ts"
      provides: "CLI tool for generating agent API keys"
  key_links:
    - from: "src/lib/agent/middleware.ts"
      to: "src/lib/agent/auth.ts"
      via: "validateApiKey import"
      pattern: "import.*validateApiKey.*from.*auth"
    - from: "src/lib/agent/auth.ts"
      to: "bcrypt"
      via: "bcrypt.compare"
      pattern: "bcrypt\\.compare"
    - from: "src/lib/agent/middleware.ts"
      to: "src/lib/agent/error-handler.ts"
      via: "handleApiError import"
      pattern: "import.*handleApiError.*from.*error-handler"
---

<objective>
Create API key authentication system and withAgentAuth() middleware wrapper.

Purpose: Enables N8N AI Agent to authenticate to APIs using Bearer tokens. The HOF middleware pattern avoids code duplication across all agent routes and ensures consistent authentication + error handling.

Output:
- `src/lib/agent/auth.ts` with API key validation using bcrypt
- `src/lib/agent/middleware.ts` with withAgentAuth() HOF
- `scripts/generate-agent-key.ts` for creating new agent API keys
</objective>

<execution_context>
@/Users/gilberto/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gilberto/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-agent-api-foundation/17-RESEARCH.md

# Plan 01 outputs (types and schema)
@.planning/phases/17-agent-api-foundation/17-01-SUMMARY.md

# Plan 02 outputs (error handler)
@.planning/phases/17-agent-api-foundation/17-02-SUMMARY.md

# Existing auth patterns
@src/lib/auth/session.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create API key validation</name>
  <files>src/lib/agent/auth.ts</files>
  <action>
Create `src/lib/agent/auth.ts` for validating Bearer tokens:

```typescript
import bcrypt from 'bcrypt'
import crypto from 'crypto'
import { prisma } from '@/lib/prisma'
import type { AgentContext } from './types'

/**
 * Validates an API key against stored bcrypt hashes in the agents table.
 * Returns AgentContext on success, null on failure.
 *
 * Performance note: bcrypt comparison is intentionally slow (~100ms per comparison).
 * With few agents (<10), iterating through all is acceptable.
 * For many agents, consider adding a key prefix for lookup.
 *
 * @param apiKey - The plain API key from Authorization header
 * @returns AgentContext if valid, null if invalid
 */
export async function validateApiKey(
  apiKey: string
): Promise<AgentContext | null> {
  try {
    // Fetch all active agents
    const agents = await prisma.agent.findMany({
      where: { active: true },
      include: {
        user: {
          select: { id: true, role: true },
        },
      },
    })

    // Compare API key against each agent's hash
    for (const agent of agents) {
      const isValid = await bcrypt.compare(apiKey, agent.apiKeyHash)

      if (isValid) {
        // Generate correlation ID for this request
        const correlationId = crypto.randomUUID()

        return {
          agentId: agent.id,
          userId: agent.user.id,
          role: agent.user.role,
          correlationId,
        }
      }
    }

    // No matching agent found
    return null
  } catch (error) {
    // Log error but don't expose details (security)
    console.error('[API Key Validation Error]', error instanceof Error ? error.message : 'Unknown')
    return null
  }
}

/**
 * Extracts Bearer token from Authorization header.
 *
 * @param authHeader - The Authorization header value
 * @returns The token if valid Bearer format, null otherwise
 */
export function extractBearerToken(authHeader: string | null): string | null {
  if (!authHeader) return null
  if (!authHeader.startsWith('Bearer ')) return null

  const token = authHeader.substring(7).trim()
  return token.length > 0 ? token : null
}
```

**Key design decisions:**
- `bcrypt.compare` is constant-time to prevent timing attacks
- correlationId generated per-request for audit trail linking
- Returns full AgentContext including inherited role from mapped user
- Errors logged but not exposed (security best practice)
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors.
Check bcrypt import: `grep "bcrypt" src/lib/agent/auth.ts`
Check exports: `grep "^export" src/lib/agent/auth.ts`
  </verify>
  <done>auth.ts exists with validateApiKey and extractBearerToken functions, uses bcrypt.compare for secure validation</done>
</task>

<task type="auto">
  <name>Task 2: Create withAgentAuth middleware</name>
  <files>src/lib/agent/middleware.ts</files>
  <action>
Create `src/lib/agent/middleware.ts` with HOF middleware pattern:

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { validateApiKey, extractBearerToken } from './auth'
import { handleApiError, errorResponse } from './error-handler'
import type { AgentContext, AgentHandler, ApiResponse } from './types'

/**
 * Higher-Order Function that wraps route handlers with agent authentication.
 *
 * Usage:
 * ```typescript
 * export const GET = withAgentAuth(async (req, context, agentContext) => {
 *   // agentContext contains: agentId, userId, role, correlationId
 *   return successResponse({ data: 'example' })
 * })
 * ```
 *
 * Flow:
 * 1. Extract Bearer token from Authorization header
 * 2. Validate token against agents table (bcrypt compare)
 * 3. If valid, call wrapped handler with AgentContext
 * 4. If invalid, return 401 with consistent error format
 * 5. Catch any errors and return consistent error response
 *
 * @param handler - The route handler to wrap
 * @returns Wrapped handler with authentication
 */
export function withAgentAuth<T = unknown>(
  handler: AgentHandler<T>
): (req: NextRequest, context: { params?: Promise<Record<string, string>> }) => Promise<NextResponse<ApiResponse<T>>> {
  return async (
    req: NextRequest,
    context: { params?: Promise<Record<string, string>> }
  ): Promise<NextResponse<ApiResponse<T>>> => {
    try {
      // 1. Extract Bearer token
      const authHeader = req.headers.get('authorization')
      const token = extractBearerToken(authHeader)

      if (!token) {
        return errorResponse(
          'Missing or invalid Authorization header. Use: Bearer <api_key>',
          401
        ) as NextResponse<ApiResponse<T>>
      }

      // 2. Validate API key
      const agentContext = await validateApiKey(token)

      if (!agentContext) {
        return errorResponse(
          'Invalid API key',
          401
        ) as NextResponse<ApiResponse<T>>
      }

      // 3. Resolve params if they're a Promise (Next.js 15+ pattern)
      const resolvedParams = context.params ? await context.params : undefined

      // 4. Call wrapped handler with agent context
      return await handler(req, { params: resolvedParams }, agentContext)
    } catch (error) {
      // 5. Handle any errors with consistent format
      return handleApiError(error) as NextResponse<ApiResponse<T>>
    }
  }
}

/**
 * Optional: Middleware that requires specific roles.
 * Use when certain agent endpoints need admin access.
 *
 * Usage:
 * ```typescript
 * export const DELETE = withAgentAuth(
 *   withRole(['ADMIN'])(async (req, context, agentContext) => {
 *     // Only ADMIN agents can access
 *   })
 * )
 * ```
 */
export function withRole(allowedRoles: string[]) {
  return <T>(handler: AgentHandler<T>): AgentHandler<T> => {
    return async (req, context, agentContext) => {
      if (!allowedRoles.includes(agentContext.role)) {
        return errorResponse(
          'Insufficient permissions',
          403
        ) as NextResponse<ApiResponse<T>>
      }

      return handler(req, context, agentContext)
    }
  }
}
```

**Key design decisions:**
- HOF pattern keeps route handlers clean (no auth boilerplate)
- Errors always return consistent ApiResponse format
- Handles Next.js 15+ async params pattern
- withRole optional for admin-only endpoints
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors.
Check withAgentAuth export: `grep "withAgentAuth" src/lib/agent/middleware.ts`
Check imports are correct: `grep "import.*from" src/lib/agent/middleware.ts`
  </verify>
  <done>middleware.ts exists with withAgentAuth HOF that handles authentication, params resolution, and error handling</done>
</task>

<task type="auto">
  <name>Task 3: Create API key generation script</name>
  <files>scripts/generate-agent-key.ts</files>
  <action>
Create `scripts/generate-agent-key.ts` for generating agent API keys:

```typescript
/**
 * Script to generate a new agent API key.
 *
 * Usage:
 *   npx ts-node scripts/generate-agent-key.ts
 *
 * Output:
 *   - API Key (store in N8N Credentials)
 *   - API Key Hash (store in database agents.api_key_hash)
 *
 * NEVER store the plain API key in the database!
 * The plain key goes only to N8N Credentials (encrypted).
 */

import bcrypt from 'bcrypt'
import crypto from 'crypto'

async function generateAgentApiKey() {
  console.log('\n=== BOTFY AGENT API KEY GENERATOR ===\n')

  // 1. Generate cryptographically secure random key
  // 32 bytes = 64 hex characters (256 bits of entropy)
  const apiKey = crypto.randomBytes(32).toString('hex')

  // 2. Hash with bcrypt (12 rounds - recommended for API keys)
  // ~300ms on modern hardware, provides timing attack protection
  const saltRounds = 12
  console.log('Generating bcrypt hash (this may take a moment)...')
  const apiKeyHash = await bcrypt.hash(apiKey, saltRounds)

  // 3. Output results
  console.log('\n--- API Key (STORE IN N8N CREDENTIALS) ---')
  console.log('This key is shown ONCE. Store it securely!')
  console.log('\n' + apiKey + '\n')

  console.log('--- API Key Hash (STORE IN DATABASE) ---')
  console.log('Add this to the agents table api_key_hash column:')
  console.log('\n' + apiKeyHash + '\n')

  // 4. Show example SQL
  console.log('--- EXAMPLE SQL ---')
  console.log(`
INSERT INTO agents (id, name, description, api_key_hash, user_id, active)
VALUES (
  gen_random_uuid(),
  'Marilia - WhatsApp Agent',
  'N8N AI Agent for WhatsApp patient interactions',
  '${apiKeyHash}',
  '<user-id-here>',  -- Replace with actual user ID
  true
);
  `)

  // 5. Show N8N Credentials setup
  console.log('--- N8N CREDENTIALS SETUP ---')
  console.log(`
In N8N:
1. Go to Credentials > Add Credential > Header Auth
2. Name: "Botfy API Key"
3. Name: "Authorization"
4. Value: "Bearer ${apiKey}"
5. Save
  `)

  console.log('=== DONE ===\n')
}

// Run the script
generateAgentApiKey().catch(console.error)
```

Add to package.json scripts (optional):
```json
{
  "scripts": {
    "generate-agent-key": "npx ts-node scripts/generate-agent-key.ts"
  }
}
```

**Important security notes:**
- The script outputs the plain API key ONCE
- Never log or store the plain key in the database
- Only the bcrypt hash is stored in agents.api_key_hash
- N8N stores the plain key in its encrypted credentials system
  </action>
  <verify>
Check script exists: `ls scripts/generate-agent-key.ts`
Run script (doesn't need DB): `npx ts-node scripts/generate-agent-key.ts` should output key and hash.
  </verify>
  <done>generate-agent-key.ts script exists, generates secure 256-bit API key, outputs bcrypt hash and usage instructions</done>
</task>

</tasks>

<verification>
1. Run `npx tsc --noEmit` - no TypeScript errors
2. Check auth.ts exports: `grep "^export" src/lib/agent/auth.ts` shows validateApiKey, extractBearerToken
3. Check middleware.ts exports: `grep "^export" src/lib/agent/middleware.ts` shows withAgentAuth, withRole
4. Run key generation: `npx ts-node scripts/generate-agent-key.ts` outputs API key and hash
5. Verify bcrypt usage: `grep "bcrypt.compare" src/lib/agent/auth.ts` and `grep "bcrypt.hash" scripts/generate-agent-key.ts`
</verification>

<success_criteria>
- src/lib/agent/auth.ts exists with validateApiKey function
- validateApiKey uses bcrypt.compare for secure comparison
- validateApiKey generates correlationId per request
- src/lib/agent/middleware.ts exists with withAgentAuth HOF
- withAgentAuth handles Bearer token extraction, validation, error handling
- withAgentAuth resolves Next.js 15+ async params
- scripts/generate-agent-key.ts generates secure API key and bcrypt hash
- Script outputs usage instructions for database and N8N
- TypeScript compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/17-agent-api-foundation/17-04-SUMMARY.md`
</output>
