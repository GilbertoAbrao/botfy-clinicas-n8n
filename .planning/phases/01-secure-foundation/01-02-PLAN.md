---
phase: 01-secure-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - .env.local
  - src/lib/supabase/client.ts
  - src/lib/supabase/server.ts
  - src/lib/supabase/middleware.ts
  - src/middleware.ts
  - prisma/schema.prisma
autonomous: true
user_setup:
  - service: supabase
    why: "Database and authentication backend"
    env_vars:
      - name: NEXT_PUBLIC_SUPABASE_URL
        source: "Supabase Dashboard → Project Settings → API → Project URL"
      - name: NEXT_PUBLIC_SUPABASE_ANON_KEY
        source: "Supabase Dashboard → Project Settings → API → anon public key"
      - name: SUPABASE_SERVICE_ROLE_KEY
        source: "Supabase Dashboard → Project Settings → API → service_role key (keep secret!)"
    dashboard_config:
      - task: "Note existing database URL"
        location: "User already has Supabase instance at https://gkweofpjwzsvlvnvfbom.supabase.co"
        details: "This connects to existing database with pacientes, agendamentos, chats tables"

must_haves:
  truths:
    - "Supabase client can connect to database"
    - "Browser client uses singleton pattern"
    - "Server client creates per-request instances"
    - "Environment variables are loaded"
  artifacts:
    - path: "src/lib/supabase/client.ts"
      provides: "Browser Supabase client (singleton)"
      exports: ["createBrowserClient"]
      min_lines: 10
    - path: "src/lib/supabase/server.ts"
      provides: "Server Supabase client (per-request factory)"
      exports: ["createServerClient"]
      min_lines: 20
    - path: "src/lib/supabase/middleware.ts"
      provides: "Middleware client for session refresh"
      exports: ["updateSession"]
      min_lines: 15
    - path: ".env.local"
      provides: "Supabase credentials"
      contains: "NEXT_PUBLIC_SUPABASE_URL"
    - path: "prisma/schema.prisma"
      provides: "Database schema (users table for auth)"
      contains: "model User"
  key_links:
    - from: "src/lib/supabase/client.ts"
      to: "process.env.NEXT_PUBLIC_SUPABASE_URL"
      via: "Environment variable"
      pattern: "NEXT_PUBLIC_SUPABASE_URL"
    - from: "src/lib/supabase/server.ts"
      to: "@supabase/ssr"
      via: "createServerClient import"
      pattern: "createServerClient.*@supabase/ssr"
    - from: "src/middleware.ts"
      to: "src/lib/supabase/middleware.ts"
      via: "updateSession call"
      pattern: "updateSession"
---

<objective>
Configure Supabase clients (@supabase/ssr) with correct patterns for Browser (singleton), Server (per-request factory), and Middleware (session refresh). Connect to existing Supabase instance.

Purpose: Establish secure Supabase integration following official SSR patterns. This is the foundation for authentication, database access, and real-time subscriptions.
Output: Working Supabase client factories that follow Next.js 15 App Router + @supabase/ssr best practices.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-secure-foundation/01-01-SUMMARY.md
@.planning/research/STACK.md
@.planning/research/PITFALLS.md

**Existing Supabase instance:**
- URL: https://gkweofpjwzsvlvnvfbom.supabase.co
- Database already contains: pacientes, servicos, agendamentos, chats, lembretes_enviados, pre_checkin, n8n_chat_histories tables
- This plan connects to existing database, does NOT create new Supabase project

**Critical patterns from research:**
- Use @supabase/ssr (NOT @supabase/auth-helpers - deprecated)
- Browser client: Singleton pattern
- Server client: Per-request factory with cookie handlers
- Middleware client: Session refresh only, minimal logic

**Critical pitfall to avoid:**
- Pitfall 1: Supabase Realtime Memory Leaks - establish cleanup patterns now
- Pitfall 2: RLS bypass - will address in Plan 05, but client setup must not bypass RLS
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Supabase dependencies and configure environment</name>
  <files>package.json, .env.local, .env.example, .gitignore</files>
  <action>
Install Supabase packages:
```bash
npm install @supabase/supabase-js @supabase/ssr
```

Versions:
- @supabase/supabase-js: v2.58.0+ (latest v2)
- @supabase/ssr: Latest (replaces deprecated auth-helpers)

Create `.env.local` with Supabase credentials:
```env
# Supabase
NEXT_PUBLIC_SUPABASE_URL=https://gkweofpjwzsvlvnvfbom.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=[user will provide]
SUPABASE_SERVICE_ROLE_KEY=[user will provide]
```

IMPORTANT: Leave ANON_KEY and SERVICE_ROLE_KEY as placeholders. User will provide actual keys from their Supabase dashboard.

Create `.env.example` for reference:
```env
# Supabase Configuration
NEXT_PUBLIC_SUPABASE_URL=https://your-project.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key
```

Ensure `.gitignore` includes:
```
.env*.local
.env.local
```

DO NOT commit .env.local to git. Only .env.example should be committed.
  </action>
  <verify>
```bash
npm list @supabase/supabase-js @supabase/ssr
```
Both packages installed. .env.local exists with placeholder values. .gitignore contains .env*.local.
  </verify>
  <done>
Supabase packages installed. Environment file created with placeholders. .gitignore protects secrets.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Supabase client factories (Browser, Server, Middleware)</name>
  <files>src/lib/supabase/client.ts, src/lib/supabase/server.ts, src/lib/supabase/middleware.ts</files>
  <action>
**1. Browser Client (singleton pattern):**

Create `src/lib/supabase/client.ts`:
```typescript
import { createBrowserClient as createClient } from '@supabase/ssr'

export function createBrowserClient() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
}
```

This is a singleton - same instance used throughout browser session. Used in Client Components only.

**2. Server Client (per-request factory):**

Create `src/lib/supabase/server.ts`:
```typescript
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'

export async function createServerSupabaseClient() {
  const cookieStore = await cookies()

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll()
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            )
          } catch {
            // Called from Server Component - ignore, cookies set on next request
          }
        },
      },
    }
  )
}
```

This creates a NEW client per request. Cookie handlers enable SSR auth. Used in Server Components, API Routes, Server Actions.

**3. Middleware Client (session refresh):**

Create `src/lib/supabase/middleware.ts`:
```typescript
import { createServerClient } from '@supabase/ssr'
import { NextResponse, type NextRequest } from 'next/server'

export async function updateSession(request: NextRequest) {
  let supabaseResponse = NextResponse.next({
    request,
  })

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return request.cookies.getAll()
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) => request.cookies.set(name, value))
          supabaseResponse = NextResponse.next({
            request,
          })
          cookiesToSet.forEach(({ name, value, options }) =>
            supabaseResponse.cookies.set(name, value, options)
          )
        },
      },
    }
  )

  // Refresh session if expired
  const {
    data: { user },
  } = await supabase.auth.getUser()

  return supabaseResponse
}
```

This ONLY refreshes session tokens. Do NOT add authorization logic here (CVE-2025-29927 bypass vulnerability). Authorization checks will be added in routes/actions in Plan 03.

**Key principle:** Middleware for session refresh ONLY. Authorization in routes + RLS.
  </action>
  <verify>
```bash
npm run build
```
Build succeeds. Check that all three files exist:
- src/lib/supabase/client.ts
- src/lib/supabase/server.ts
- src/lib/supabase/middleware.ts

No TypeScript errors. Imports resolve correctly.
  </verify>
  <done>
Three Supabase client factories created following @supabase/ssr patterns. Browser (singleton), Server (per-request), Middleware (session refresh). Build succeeds.
  </done>
</task>

<task type="auto">
  <name>Task 3: Configure Next.js middleware for session refresh</name>
  <files>src/middleware.ts</files>
  <action>
Create `src/middleware.ts`:
```typescript
import { updateSession } from '@/lib/supabase/middleware'
import { NextResponse, type NextRequest } from 'next/server'

export async function middleware(request: NextRequest) {
  return await updateSession(request)
}

export const config = {
  matcher: [
    /*
     * Match all request paths except:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * - public folder
     */
    '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',
  ],
}
```

This runs on every request to refresh Supabase session tokens.

CRITICAL: This middleware ONLY refreshes sessions. It does NOT check authorization. Per CVE-2025-29927, middleware can be bypassed with x-middleware-subrequest header. Authorization will be implemented in:
- Plan 03: Route-level checks in API routes and Server Actions
- Plan 05: Row Level Security (RLS) at database level

**Defense-in-depth:** Middleware + Route checks + RLS = comprehensive security.
  </action>
  <verify>
```bash
npm run build
```
Build succeeds. src/middleware.ts exists. No TypeScript errors.
  </verify>
  <done>
Next.js middleware configured to refresh Supabase sessions on every request. Middleware does NOT enforce authorization (follows CVE-2025-29927 mitigation pattern).
  </done>
</task>

<task type="auto">
  <name>Task 4: Create Prisma schema with User table for Supabase Auth</name>
  <files>prisma/schema.prisma, package.json</files>
  <action>
Install Prisma:
```bash
npm install -D prisma
npm install @prisma/client
```

Initialize Prisma:
```bash
npx prisma init
```

This creates:
- prisma/schema.prisma
- .env (if not exists)

Update `prisma/schema.prisma`:
```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Supabase Auth users table (managed by Supabase Auth, reference only)
model User {
  id        String   @id @default(uuid()) @db.Uuid
  email     String   @unique
  role      String   @default("atendente") // "admin" or "atendente"
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("users")
}
```

Add DATABASE_URL to `.env.local`:
```env
DATABASE_URL=postgresql://postgres:[password]@db.gkweofpjwzsvlvnvfbom.supabase.co:5432/postgres
```

User will provide actual password.

Generate Prisma Client:
```bash
npx prisma generate
```

DO NOT run `npx prisma db push` yet - we're connecting to existing database. Schema introspection and migration will be done carefully in next plan to avoid conflicts with existing N8N tables.

IMPORTANT: This User model is for TypeScript types only. The actual users table may already exist in Supabase or will be managed by Supabase Auth. We'll reconcile schema with existing database in Plan 03.
  </action>
  <verify>
```bash
npx prisma generate
```
Prisma Client generates successfully. node_modules/.prisma/client exists.

```bash
npm run build
```
Build succeeds.
  </verify>
  <done>
Prisma installed and schema created with User model. DATABASE_URL configured in .env.local (placeholder). Prisma Client generated. No database push yet (existing db).
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] @supabase/supabase-js and @supabase/ssr installed
- [ ] .env.local exists with Supabase URL and placeholder keys
- [ ] .gitignore protects .env*.local
- [ ] src/lib/supabase/client.ts (browser singleton)
- [ ] src/lib/supabase/server.ts (server per-request)
- [ ] src/lib/supabase/middleware.ts (session refresh)
- [ ] src/middleware.ts configured with updateSession
- [ ] prisma/schema.prisma with User model
- [ ] Prisma Client generated (node_modules/.prisma/client)
- [ ] Build succeeds without errors
</verification>

<success_criteria>
- All tasks completed
- Supabase clients configured following @supabase/ssr patterns
- Browser/Server/Middleware clients follow official SSR guide
- Environment variables configured (placeholders for user secrets)
- Middleware refreshes sessions without authorization logic (CVE-2025-29927 mitigation)
- Prisma schema ready for existing database connection
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/01-secure-foundation/01-02-SUMMARY.md`

**User action required:** After this plan executes, user must:
1. Get NEXT_PUBLIC_SUPABASE_ANON_KEY from Supabase Dashboard
2. Get SUPABASE_SERVICE_ROLE_KEY from Supabase Dashboard
3. Get database password for DATABASE_URL
4. Update `.env.local` with actual values
</output>
