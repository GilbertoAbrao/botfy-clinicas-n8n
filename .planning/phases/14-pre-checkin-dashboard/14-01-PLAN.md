---
phase: 14-pre-checkin-dashboard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/validations/pre-checkin.ts
  - src/hooks/use-pre-checkin.ts
  - src/app/api/pre-checkin/route.ts
  - src/app/api/pre-checkin/analytics/route.ts
  - src/lib/audit/logger.ts
autonomous: true

must_haves:
  truths:
    - "API returns paginated pre-checkin records with related patient/appointment data"
    - "API supports filtering by status, date range, and patient name search"
    - "Analytics endpoint returns completion rate, pending count, and overdue count"
    - "Hook provides loading, error, and refetch functionality"
  artifacts:
    - path: "src/lib/validations/pre-checkin.ts"
      provides: "Zod schemas and TypeScript types for pre-checkin"
      exports: ["PreCheckin", "PreCheckinFilters", "PreCheckinStatus", "preCheckinFiltersSchema"]
    - path: "src/hooks/use-pre-checkin.ts"
      provides: "React hook for fetching pre-checkin data"
      exports: ["usePreCheckin", "usePreCheckinAnalytics"]
    - path: "src/app/api/pre-checkin/route.ts"
      provides: "GET endpoint for pre-checkin list"
      exports: ["GET"]
    - path: "src/app/api/pre-checkin/analytics/route.ts"
      provides: "GET endpoint for analytics metrics"
      exports: ["GET"]
  key_links:
    - from: "src/hooks/use-pre-checkin.ts"
      to: "/api/pre-checkin"
      via: "fetch in useEffect"
      pattern: "fetch.*api/pre-checkin"
    - from: "src/app/api/pre-checkin/route.ts"
      to: "supabase.from('pre_checkin')"
      via: "database query with joins"
      pattern: "from\\('pre_checkin'\\)"
---

<objective>
Create the data layer for Pre-Checkin Dashboard including API routes, React hook, and TypeScript types.

Purpose: Provide data fetching infrastructure that supports filtering, pagination, and analytics calculations for the dashboard.
Output: Working API endpoints and hook that can be consumed by UI components.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-pre-checkin-dashboard/14-CONTEXT.md
@.planning/phases/14-pre-checkin-dashboard/14-RESEARCH.md

Reference patterns:
@src/hooks/use-agenda-list.ts
@src/lib/validations/appointment.ts
@src/app/api/agendamentos/list/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zod schemas and types for pre-checkin</name>
  <files>src/lib/validations/pre-checkin.ts</files>
  <action>
Create validation schemas and TypeScript types:

1. Create PreCheckinStatus type with values: 'pendente', 'em_andamento', 'completo', 'incompleto'

2. Create PreCheckin interface matching database schema:
   - id: number
   - agendamento_id: number
   - paciente_id: number
   - status: PreCheckinStatus
   - dados_confirmados: boolean | null
   - documentos_enviados: boolean | null
   - instrucoes_enviadas: boolean | null
   - pendencias: any | null (JSONB)
   - mensagem_enviada_em: string | null
   - lembrete_enviado_em: string | null
   - created_at: string
   - updated_at: string
   - Related data:
     - agendamento: { id, data_hora, servico: { nome } }
     - paciente: { id, nome, telefone }

3. Create PreCheckinFilters interface:
   - status?: PreCheckinStatus
   - dateStart?: string
   - dateEnd?: string
   - search?: string
   - page?: number
   - limit?: number

4. Create Zod schema preCheckinFiltersSchema with defaults:
   - page: 1
   - limit: 50

5. Create STATUS_PRE_CHECKIN array constant for UI iteration.

6. Create calculateProgress helper function that takes PreCheckin and returns 0-100 based on boolean fields (dados_confirmados, documentos_enviados, instrucoes_enviadas).

Follow existing pattern from src/lib/validations/appointment.ts.
  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit`</verify>
  <done>Types exported, schema validates correctly, calculateProgress returns 0/33/66/100</done>
</task>

<task type="auto">
  <name>Task 2: Create API routes for pre-checkin list and analytics</name>
  <files>src/app/api/pre-checkin/route.ts, src/app/api/pre-checkin/analytics/route.ts, src/lib/audit/logger.ts</files>
  <action>
**First, update src/lib/audit/logger.ts:**
Add new AuditAction enum values:
- VIEW_PRE_CHECKIN = 'VIEW_PRE_CHECKIN'
- UPDATE_PRE_CHECKIN = 'UPDATE_PRE_CHECKIN'
- SEND_PRE_CHECKIN_REMINDER = 'SEND_PRE_CHECKIN_REMINDER'

**Then create src/app/api/pre-checkin/route.ts:**

1. Import auth, supabase server client, audit logger, Zod schema

2. GET handler:
   - Auth check (reject if not logged in)
   - RBAC check: only ADMIN and ATENDENTE roles
   - Parse and validate query params with preCheckinFiltersSchema
   - Build Supabase query:
     ```
     supabase
       .from('pre_checkin')
       .select(`
         *,
         agendamento:agendamentos!pre_checkin_agendamento_id_fkey(
           id,
           data_hora,
           servico:servicos!agendamentos_servico_id_fkey(nome)
         ),
         paciente:pacientes!pre_checkin_paciente_id_fkey(
           id,
           nome,
           telefone
         )
       `, { count: 'exact' })
     ```
   - Apply filters:
     - status: .eq('status', status)
     - dateStart: .gte('agendamento.data_hora', dateStart) - NOTE: This may need RPC for nested filter
     - dateEnd: .lte('agendamento.data_hora', dateEnd)
     - search: .ilike('paciente.nome', `%${search}%`) - NOTE: May need RPC for nested filter
   - If nested filters don't work, fetch all and filter in-memory (acceptable for 50 items/page)
   - Apply pagination: .range(offset, offset + limit - 1)
   - Order by appointment date descending
   - Return { data, pagination: { page, limit, total, totalPages } }
   - Audit log: AuditAction.VIEW_PRE_CHECKIN

**Then create src/app/api/pre-checkin/analytics/route.ts:**

1. Same auth/RBAC pattern

2. GET handler:
   - Parse dateStart, dateEnd from query params
   - Fetch all pre_checkin records (with date filter if provided)
   - Calculate:
     - total: count of all records
     - completed: count where status = 'completo'
     - pending: count where status = 'pendente' OR 'em_andamento'
     - overdue: count where status != 'completo' AND appointment is < 12 hours away
       - Use TZDate with 'America/Sao_Paulo' for DST-aware calculation
       - Use differenceInHours from date-fns
     - completionRate: Math.round((completed / total) * 100) or 0 if total is 0
   - Return { completionRate, pendingCount, overdueCount, total }

Follow existing patterns from src/app/api/agendamentos/list/route.ts and src/app/api/lembretes-enviados/route.ts.
  </action>
  <verify>
Test with curl:
- `curl -s http://localhost:3051/api/pre-checkin | head -c 500` returns JSON with data array
- `curl -s http://localhost:3051/api/pre-checkin/analytics | head -c 200` returns JSON with metrics
  </verify>
  <done>Both endpoints return valid JSON, auth/RBAC enforced, pagination works</done>
</task>

<task type="auto">
  <name>Task 3: Create React hooks for pre-checkin data fetching</name>
  <files>src/hooks/use-pre-checkin.ts</files>
  <action>
Create data fetching hooks following use-agenda-list.ts pattern:

1. **usePreCheckin hook:**
   - Accept filters: PreCheckinFilters
   - State: preCheckins (array), pagination, loading, error
   - fetchPreCheckins callback:
     - Build URLSearchParams from filters
     - Fetch /api/pre-checkin?params
     - Handle errors gracefully (set error state, don't throw)
   - useEffect to call fetchPreCheckins when filters change
   - Return { preCheckins, pagination, loading, error, refetch }

2. **usePreCheckinAnalytics hook:**
   - Accept optional dateStart, dateEnd params
   - State: analytics object, loading, error
   - fetchAnalytics callback:
     - Build URLSearchParams
     - Fetch /api/pre-checkin/analytics?params
   - Return { analytics, loading, error, refetch }

3. Export interfaces:
   - PreCheckinPagination (same as AgendaListPagination)
   - PreCheckinAnalytics: { completionRate, pendingCount, overdueCount, total }
   - UsePreCheckinReturn
   - UsePreCheckinAnalyticsReturn

Ensure hooks are 'use client' directive at top.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>Both hooks exported, properly typed, follow existing hook patterns</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. API endpoints respond with correct JSON structure
3. Auth returns 401 for unauthenticated requests
4. RBAC returns 403 for non-ADMIN/ATENDENTE roles
5. Pagination returns correct totalPages calculation
6. Analytics returns reasonable metrics (not NaN, not undefined)
</verification>

<success_criteria>
- GET /api/pre-checkin returns paginated list with patient and appointment data
- GET /api/pre-checkin/analytics returns completionRate, pendingCount, overdueCount
- usePreCheckin hook fetches data and supports refetch
- usePreCheckinAnalytics hook fetches analytics data
- All types properly exported from validations file
- Audit logging added for pre-checkin views
</success_criteria>

<output>
After completion, create `.planning/phases/14-pre-checkin-dashboard/14-01-SUMMARY.md`
</output>
