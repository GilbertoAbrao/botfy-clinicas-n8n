---
phase: 20-complex-tools
plan: 03
type: execute
wave: 3
depends_on: ["20-02"]
files_modified:
  - src/lib/services/document-service.ts
  - src/app/api/agent/documentos/processar/route.ts
  - src/lib/agent/error-handler.ts
autonomous: true

must_haves:
  truths:
    - "AI Agent can upload documents via POST /api/agent/documentos/processar"
    - "Uploaded files are validated, stored, and fields extracted"
    - "Duplicate uploads with same idempotency key return cached result"
    - "Processing result includes document type, extracted fields, and storage path"
  artifacts:
    - path: "src/lib/services/document-service.ts"
      provides: "Document processing business logic"
      exports: ["processDocument"]
    - path: "src/app/api/agent/documentos/processar/route.ts"
      provides: "POST handler for document processing"
      exports: ["POST"]
  key_links:
    - from: "src/app/api/agent/documentos/processar/route.ts"
      to: "src/lib/services/document-service.ts"
      via: "import processDocument"
      pattern: "import.*processDocument.*from.*document-service"
    - from: "src/lib/services/document-service.ts"
      to: "src/lib/document/vision-extractor.ts"
      via: "import extractDocumentFields"
      pattern: "import.*extractDocumentFields.*from.*vision-extractor"
    - from: "src/lib/services/document-service.ts"
      to: "src/lib/document/storage-service.ts"
      via: "import uploadPatientDocument"
      pattern: "import.*uploadPatientDocument.*from.*storage-service"
---

<objective>
Implement the document processing API endpoint with full integration.

Purpose: Complete CMPLX-01 and CMPLX-02 requirements by creating the POST /api/agent/documentos/processar endpoint that validates uploads, extracts fields via Vision API, stores files in Supabase, and returns structured results with idempotency support.

Output:
- Document service with processDocument function
- API route handling multipart form data with authentication
- Error handler updates for document-specific errors
</objective>

<execution_context>
@/Users/gilberto/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gilberto/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-complex-tools/20-RESEARCH.md
@.planning/phases/20-complex-tools/20-01-SUMMARY.md
@.planning/phases/20-complex-tools/20-02-SUMMARY.md

# Plan 01-02 artifacts
@src/lib/document/document-types.ts
@src/lib/document/document-validator.ts
@src/lib/document/vision-extractor.ts
@src/lib/document/storage-service.ts
@src/lib/validations/document-schemas.ts

# Existing patterns
@src/lib/agent/middleware.ts
@src/lib/agent/error-handler.ts
@src/lib/idempotency/idempotency-service.ts
@src/lib/audit/logger.ts
@src/app/api/agent/agendamentos/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update error handler with document-specific errors</name>
  <files>src/lib/agent/error-handler.ts</files>
  <action>
Add document-specific error mappings to KNOWN_ERROR_STATUS_MAP in error-handler.ts:

```typescript
// Add to KNOWN_ERROR_STATUS_MAP:
'File size exceeds 5MB limit': 413,
'File is empty': 400,
'Unable to determine file type from content': 400,
'File type not allowed': 415,  // Unsupported Media Type
'MIME type mismatch': 400,
'Failed to extract document fields': 422,
'Document extraction refused': 422,
'Failed to upload document': 500,
'No file provided': 400,
'patientId is required': 400,
```

These will map document validation errors to appropriate HTTP status codes.
  </action>
  <verify>
Grep for 'File size exceeds': `grep "File size exceeds" src/lib/agent/error-handler.ts`
Should show the new entry in KNOWN_ERROR_STATUS_MAP.
  </verify>
  <done>Error handler updated with document-specific error mappings</done>
</task>

<task type="auto">
  <name>Task 2: Create document processing service</name>
  <files>src/lib/services/document-service.ts</files>
  <action>
Create new file `src/lib/services/document-service.ts` implementing the main processing logic:

1. **Imports**:
   ```typescript
   import { validateDocumentUpload } from '@/lib/document/document-validator'
   import { extractDocumentFields } from '@/lib/document/vision-extractor'
   import { uploadPatientDocument } from '@/lib/document/storage-service'
   import type { ProcessDocumentResult, ExtractedDocument } from '@/lib/document/document-types'
   import type { AgentContext } from '@/lib/agent/types'
   ```

2. **ProcessDocumentInput interface**:
   ```typescript
   export interface ProcessDocumentInput {
     file: File
     patientId: string | number
     agentContext: AgentContext
   }
   ```

3. **processDocument function**:
   ```typescript
   export async function processDocument(
     input: ProcessDocumentInput
   ): Promise<ProcessDocumentResult> {
     const { file, patientId, agentContext } = input
     const startTime = Date.now()

     // 1. Validate file (magic bytes, size, MIME type)
     const validated = await validateDocumentUpload(file)

     // 2. Convert buffer to base64 for Vision API
     const imageBase64 = validated.buffer.toString('base64')

     // 3. Extract fields using GPT-4o Vision
     const extracted = await extractDocumentFields(imageBase64, validated.mimeType)

     // 4. Upload original file to Supabase Storage
     const storagePath = await uploadPatientDocument(
       String(patientId),
       validated.buffer,
       validated.mimeType,
       extracted.documentType,
       file.name
     )

     // 5. Build result
     const result: ProcessDocumentResult = {
       extracted,
       storagePath,
       originalFilename: file.name,
       mimeType: validated.mimeType,
       fileSize: file.size,
       processedAt: new Date().toISOString(),
     }

     // Log processing time (for monitoring Vision API latency)
     const duration = Date.now() - startTime
     console.log(`[Document Processing] Type: ${extracted.documentType}, Duration: ${duration}ms, Confidence: ${extracted.confidence}`)

     return result
   }
   ```

Note: This function orchestrates validation -> extraction -> storage.
Errors from any step will propagate up to the API route for consistent handling.
No PHI is logged - only document type, duration, and confidence level.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit src/lib/services/document-service.ts`
  </verify>
  <done>Document service created with processDocument function orchestrating validation, extraction, and storage</done>
</task>

<task type="auto">
  <name>Task 3: Create document processing API route</name>
  <files>src/app/api/agent/documentos/processar/route.ts</files>
  <action>
Create new file `src/app/api/agent/documentos/processar/route.ts` with POST handler:

1. **Imports**:
   ```typescript
   import { NextRequest } from 'next/server'
   import { withAgentAuth } from '@/lib/agent/middleware'
   import { successResponse, errorResponse, handleApiError } from '@/lib/agent/error-handler'
   import { processDocument } from '@/lib/services/document-service'
   import { checkIdempotencyKey, storeIdempotencyResult, hashRequestBody } from '@/lib/idempotency/idempotency-service'
   import { logAudit, AuditAction } from '@/lib/audit/logger'
   import { createHash } from 'crypto'
   ```

2. **hashFileContent helper** — For idempotency fallback:
   ```typescript
   async function hashFileContent(file: File, patientId: string): Promise<string> {
     const buffer = await file.arrayBuffer()
     const hash = createHash('sha256')
       .update(Buffer.from(buffer))
       .update(patientId)
       .digest('hex')
     return `file:${hash}`
   }
   ```

3. **POST handler**:
   ```typescript
   /**
    * POST /api/agent/documentos/processar
    *
    * Process an uploaded document (RG, CPF, CNS, insurance card).
    * Validates file, extracts fields using GPT-4o Vision, stores in Supabase.
    *
    * Authentication: Bearer token (API key from agents table)
    *
    * Request body (multipart/form-data):
    * - file: File (required) — Image or PDF document (max 5MB)
    * - patientId: string (required) — Patient ID for storage organization
    * - idempotencyKey: string (optional) — UUID for duplicate prevention
    *
    * Response:
    * {
    *   success: true,
    *   data: {
    *     extracted: {
    *       documentType: "RG" | "CPF" | "CNS" | "CARTEIRINHA_CONVENIO" | "UNKNOWN",
    *       confidence: "high" | "medium" | "low",
    *       // ... type-specific fields
    *     },
    *     storagePath: string,
    *     originalFilename: string,
    *     mimeType: string,
    *     fileSize: number,
    *     processedAt: string (ISO 8601)
    *   }
    * }
    *
    * Errors:
    * - 400: Missing file, missing patientId, validation error
    * - 413: File too large (>5MB)
    * - 415: Unsupported file type
    * - 422: Extraction failed, idempotency key mismatch
    * - 500: Storage or API error
    */
   export const POST = withAgentAuth(async (req: NextRequest, context, agentContext) => {
     try {
       // 1. Parse multipart form data (native Next.js)
       const formData = await req.formData()

       // 2. Extract fields
       const file = formData.get('file') as File | null
       const patientId = formData.get('patientId') as string | null
       const idempotencyKey = formData.get('idempotencyKey') as string | null

       // 3. Validate required fields
       if (!file) {
         return errorResponse('No file provided', 400)
       }

       if (!patientId) {
         return errorResponse('patientId is required', 400)
       }

       // 4. Handle idempotency
       let idempotencyHash: string | undefined
       if (idempotencyKey) {
         // Use provided key + patientId hash
         idempotencyHash = hashRequestBody({ patientId, filename: file.name, size: file.size })

         try {
           const idempotencyResult = await checkIdempotencyKey(idempotencyKey, idempotencyHash)

           if (!idempotencyResult.isNew && idempotencyResult.storedResponse) {
             // Log idempotent hit
             logAudit({
               userId: agentContext.userId,
               action: AuditAction.AGENT_PROCESS_DOCUMENT,
               resource: 'agent_api',
               details: {
                 agentId: agentContext.agentId,
                 correlationId: agentContext.correlationId,
                 idempotencyKey,
                 idempotencyHit: true,
               },
             }).catch(console.error)

             return successResponse(idempotencyResult.storedResponse)
           }
         } catch (idempotencyError) {
           if (idempotencyError instanceof Error &&
               idempotencyError.message.includes('Idempotency key reused')) {
             return errorResponse(idempotencyError.message, 422)
           }
           throw idempotencyError
         }
       }

       // 5. Process document (validation + extraction + storage)
       const result = await processDocument({
         file,
         patientId,
         agentContext,
       })

       // 6. Store idempotency result if key was provided
       if (idempotencyKey && idempotencyHash) {
         await storeIdempotencyResult(idempotencyKey, idempotencyHash, result)
       }

       // 7. Audit log (no PHI - only document type and metadata)
       logAudit({
         userId: agentContext.userId,
         action: AuditAction.AGENT_PROCESS_DOCUMENT,
         resource: 'agent_api',
         resourceId: result.storagePath,
         details: {
           agentId: agentContext.agentId,
           correlationId: agentContext.correlationId,
           patientId,
           documentType: result.extracted.documentType,
           confidence: result.extracted.confidence,
           mimeType: result.mimeType,
           fileSize: result.fileSize,
           idempotencyKey,
         },
       }).catch(console.error)

       // 8. Return result
       return successResponse(result)
     } catch (error) {
       return handleApiError(error)
     }
   })
   ```

Note: Using native Next.js `req.formData()` for multipart parsing (no formidable/multer needed).
Idempotency uses file metadata hash (not content) for performance - checking content would require reading entire file twice.
  </action>
  <verify>
Create directory and verify route file:
```bash
mkdir -p src/app/api/agent/documentos/processar
```
TypeScript compiles: `npx tsc --noEmit src/app/api/agent/documentos/processar/route.ts`
  </verify>
  <done>Document processing API route created with multipart handling, idempotency, and audit logging</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. Directory structure exists: `ls src/app/api/agent/documentos/processar/`
3. Route exports POST handler
4. Curl test (will return 401 without valid key):
   ```bash
   curl -X POST http://localhost:3051/api/agent/documentos/processar \
     -H "Authorization: Bearer test-key" \
     -F "file=@test.jpg" \
     -F "patientId=1"
   ```
5. Error messages map to correct HTTP status codes
6. Audit log contains AGENT_PROCESS_DOCUMENT entries with document type (no PHI)
</verification>

<success_criteria>
- POST /api/agent/documentos/processar accepts multipart form data
- File validation rejects oversized (>5MB), empty, and unsupported files
- Vision API extracts fields and detects document type
- Extracted document is stored in Supabase with unique path per patient/type
- Idempotency key prevents duplicate processing
- Audit log captures document type and confidence (no PHI)
- Error responses use appropriate HTTP status codes (400, 413, 415, 422, 500)
</success_criteria>

<output>
After completion, create `.planning/phases/20-complex-tools/20-03-SUMMARY.md`
</output>
