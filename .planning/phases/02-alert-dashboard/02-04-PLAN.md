---
plan_id: 02-04
phase: 2
wave: 3
title: Real-time Updates & Metrics Dashboard
status: not_started
dependencies: [02-01, 02-02, 02-03]
must_haves:
  truths:
    - Alert list updates in real-time when new alerts arrive (no manual refresh)
    - Alert detail view updates when status changes (multi-user scenario)
    - Supabase real-time subscriptions have proper cleanup (no memory leaks)
    - Key metrics dashboard shows: agendamentos hoje, taxa de confirmação, conversas ativas
    - Service status indicators show: Evolution API, N8N, Supabase (healthy/degraded/down)
    - All subscriptions unsubscribe on component unmount
  artifacts:
    - src/lib/realtime/alerts.ts (real-time subscription helpers)
    - src/lib/realtime/cleanup.ts (subscription cleanup utilities)
    - src/components/dashboard/metrics-dashboard.tsx (key metrics widget)
    - src/components/dashboard/service-status.tsx (service health indicators)
    - src/lib/api/metrics.ts (metrics calculation functions)
  key_links:
    - Supabase Realtime docs: https://supabase.com/docs/guides/realtime
    - Memory leak prevention: Phase 1 pitfalls research
---

# Plan 02-04: Real-time Updates & Metrics Dashboard

## Objective

Implement Supabase real-time subscriptions for alerts with memory leak prevention. Add key metrics dashboard (agendamentos hoje, taxa de confirmação, conversas ativas) and service status indicators. Complete Phase 2 requirements.

## Execution Context

**Prerequisites:**
- Plans 02-01, 02-02, 02-03 complete (database, UI, detail view)
- Supabase real-time enabled (check Supabase dashboard settings)
- React hooks knowledge (useEffect cleanup patterns)

**Key Files:**
- src/lib/supabase/browser.ts (Supabase browser client)
- src/app/dashboard/alerts/page.tsx (alert list page from 02-02)
- src/app/dashboard/page.tsx (main dashboard - add metrics widget)

**External Resources:**
- Supabase Realtime: https://supabase.com/docs/guides/realtime/postgres-changes
- React useEffect cleanup: https://react.dev/reference/react/useEffect#cleanup

## Context

Real-time updates are critical for alert-first operations. Staff need to see new alerts within 5 seconds without manual refresh. However, Supabase real-time has memory leak pitfalls (Phase 1 research) - subscriptions must be cleaned up properly.

Key metrics dashboard provides "at glance" operational visibility:
- **Agendamentos hoje**: How many appointments scheduled for today?
- **Taxa de confirmação**: What % of appointments are confirmed?
- **Conversas ativas**: How many AI conversations currently open?

Service status indicators show external dependencies health:
- **Evolution API**: WhatsApp message gateway (check /health endpoint)
- **N8N**: Workflow automation (check /healthz endpoint)
- **Supabase**: Database and auth (check connection)

**Requirements Covered:**
- ALERT-01: Real-time alert queue (implicit - updates without refresh)
- UX-08: Key metrics at glance
- UX-09: Service status indicators

**Critical Risk Mitigation:**
- Memory leaks from Supabase subscriptions (Phase 1 research identified this)
- Solution: Mandatory cleanup in useEffect return function

## Tasks

### Task 1: Create real-time subscription helpers
- [ ] Create src/lib/realtime/alerts.ts
- [ ] Implement useAlertSubscription() hook:
  - Accept callback: onAlertChange(payload)
  - Subscribe to 'alerts' table changes (INSERT, UPDATE, DELETE)
  - Use Supabase browser client: `supabase.channel('alerts').on('postgres_changes', ...)`
  - Filter to only relevant changes (new alerts, status updates)
  - Return cleanup function to unsubscribe
- [ ] Implement subscription cleanup helper:
  - Store subscription reference
  - Unsubscribe on unmount: `subscription.unsubscribe()`
  - Remove event listeners
  - Log cleanup for debugging (dev only)
- [ ] Add TypeScript types:
  - `AlertChangePayload` type (eventType, new, old)
  - `SubscriptionStatus` type (subscribed, error, disconnected)
- [ ] Test subscription: Insert alert via Supabase SQL, verify callback fires
- [ ] Test cleanup: Mount/unmount component multiple times, check for memory leaks (Chrome DevTools)

### Task 2: Add real-time updates to alert list
- [ ] Edit src/app/dashboard/alerts/page.tsx
- [ ] Convert to Client Component (add 'use client' directive)
- [ ] Import useAlertSubscription hook
- [ ] Set up subscription in useEffect:
  - Call useAlertSubscription(handleAlertChange)
  - On INSERT: Add new alert to list (prepend to array)
  - On UPDATE: Update existing alert in list (match by ID)
  - On DELETE: Remove alert from list
  - Show toast notification for new urgent alerts
  - Play subtle sound for urgent alerts (optional)
- [ ] Ensure cleanup on unmount:
  - Return cleanup function from useEffect
  - Verify subscription.unsubscribe() is called
- [ ] Add connection status indicator:
  - Show "Conectado" badge when subscribed
  - Show "Reconectando..." badge when disconnected
  - Use Supabase channel.on('system', ...) events
- [ ] Handle edge cases:
  - Duplicate alerts (deduplicate by ID)
  - Race conditions (alert arrives before initial fetch completes)
  - Subscription errors (show error message, allow retry)
- [ ] Test real-time: Open two browser windows, create alert in one, verify appears in other
- [ ] Test cleanup: Open/close page multiple times, verify no memory leaks

### Task 3: Add real-time updates to alert detail view
- [ ] Edit src/app/dashboard/alerts/[id]/page.tsx
- [ ] Convert to Client Component if not already
- [ ] Set up subscription for single alert updates:
  - Subscribe to 'alerts' table changes filtered by alert ID
  - On UPDATE: Refresh alert data (refetch or update local state)
  - Show toast notification: "Alerta atualizado por outro usuário"
- [ ] Handle status conflicts:
  - If user is editing status and another user updates it, show warning
  - Offer to reload page with latest data
- [ ] Ensure cleanup on unmount
- [ ] Test multi-user scenario: Two users view same alert, one updates status, other sees update

### Task 4: Create metrics calculation functions
- [ ] Create src/lib/api/metrics.ts
- [ ] Implement getAgendamentosHoje():
  - Query appointments table filtered by scheduledAt = today
  - Return count of appointments
  - Cache result for 5 minutes (avoid excessive queries)
- [ ] Implement getTaxaConfirmacao():
  - Query appointments with status = confirmed vs total tentative
  - Calculate percentage: (confirmed / (confirmed + tentative)) * 100
  - Return percentage as number (e.g., 75.5)
- [ ] Implement getConversasAtivas():
  - Query conversations with status = IA or HUMANO (not FINALIZADO)
  - Return count of active conversations
- [ ] Add error handling: Return 0 or null if query fails
- [ ] Add TypeScript types:
  - `MetricsData` type (agendamentosHoje, taxaConfirmacao, conversasAtivas)
- [ ] Test functions with seed data

### Task 5: Create metrics dashboard widget
- [ ] Create src/components/dashboard/metrics-dashboard.tsx
- [ ] Build MetricsDashboard component:
  - Fetch metrics on mount: getAgendamentosHoje(), getTaxaConfirmacao(), getConversasAtivas()
  - Display metrics in card grid (3 columns on desktop, 1 column on mobile)
  - Card 1: "Agendamentos Hoje"
    - Large number display (e.g., "12")
    - Icon: Calendar icon
    - Subtitle: "agendados para hoje"
  - Card 2: "Taxa de Confirmação"
    - Large percentage display (e.g., "78%")
    - Icon: CheckCircle icon
    - Subtitle: "confirmação de agendamentos"
    - Color code: Green if >70%, yellow if 50-70%, red if <50%
  - Card 3: "Conversas Ativas"
    - Large number display (e.g., "5")
    - Icon: MessageCircle icon
    - Subtitle: "conversas em andamento"
  - Add loading skeleton while metrics fetch
  - Add error state if metrics fail to load
  - Refresh metrics every 5 minutes (auto-refresh)
- [ ] Style with Botfy brand colors
- [ ] Add hover effect (subtle scale/shadow)
- [ ] Mobile-responsive: Stack cards vertically, large touch-friendly

### Task 6: Create service status component
- [ ] Create src/components/dashboard/service-status.tsx
- [ ] Build ServiceStatus component:
  - Check health of external services on mount:
    - Evolution API: Fetch /health endpoint (or check if configured in env)
    - N8N: Fetch /healthz endpoint (or check if configured in env)
    - Supabase: Test database connection (simple query: SELECT 1)
  - Display status indicators:
    - Service name (Evolution API, N8N, Supabase)
    - Status badge: Green "Operacional", Yellow "Degradado", Red "Indisponível"
    - Last checked timestamp
  - Show compact view by default (status badges only)
  - Add expand button to show details (error messages, response times)
  - Refresh health checks every 2 minutes
- [ ] Handle errors gracefully:
  - If health endpoint unreachable, mark as "Indisponível"
  - Show error message in expanded view
  - Add manual retry button
- [ ] Add configuration:
  - Read service URLs from environment variables
  - If URL not configured, show "Não configurado" status
  - Add links to service dashboards (if URLs available)
- [ ] Style with status colors (green/yellow/red)
- [ ] Mobile-responsive: Stack status indicators vertically

### Task 7: Integrate metrics and service status into main dashboard
- [ ] Edit src/app/dashboard/page.tsx
- [ ] Add MetricsDashboard component below page header
- [ ] Add ServiceStatus component at bottom of dashboard (or in sidebar)
- [ ] Layout structure:
  - Top: Page header with title and navigation
  - Below header: MetricsDashboard (key metrics cards)
  - Main area: Quick actions or alert summary (optional)
  - Bottom or sidebar: ServiceStatus component
- [ ] Add spacing and padding for visual separation
- [ ] Test on mobile: Verify components stack properly
- [ ] Verify build passes: `npm run build`

### Task 8: Document memory leak prevention patterns
- [ ] Create src/lib/realtime/cleanup.ts
- [ ] Document cleanup pattern:
  ```typescript
  // ✅ CORRECT: Cleanup subscription on unmount
  useEffect(() => {
    const subscription = supabase.channel('alerts').on(...)
    return () => {
      subscription.unsubscribe()
    }
  }, [])

  // ❌ INCORRECT: No cleanup (memory leak)
  useEffect(() => {
    supabase.channel('alerts').on(...)
  }, [])
  ```
- [ ] Export reusable cleanup utility: `cleanupSubscription(subscription)`
- [ ] Add JSDoc comments explaining memory leak risks
- [ ] Reference Phase 1 research findings (Supabase real-time pitfalls)

## Verification

**Must Pass:**
1. Open /dashboard/alerts, insert new alert via Supabase SQL - alert appears in list within 5 seconds (no refresh)
2. Open alert detail view, update status via SQL - detail view updates within 5 seconds
3. Open two browser windows, update alert in one - other window shows update in real-time
4. Open /dashboard, see metrics dashboard with correct counts (agendamentos hoje, taxa confirmação, conversas ativas)
5. Service status indicators show correct status (green if services healthy)
6. Close alert list page, reopen - no duplicate subscriptions (check network tab for multiple channel connections)
7. Open/close alert page 10 times - no memory leaks (check Chrome DevTools Memory profiler)
8. Mobile responsive: Metrics cards stack vertically on 375px width
9. Test edge case: Disconnect internet, reconnect - subscriptions recover and show "Reconectando..." then "Conectado"
10. Build passes: `npm run build`

**Quality Checks:**
- All subscriptions have cleanup functions (grep for `.on(` and verify matching `.unsubscribe()`)
- Toast notifications for urgent alerts (not too noisy - only urgent)
- Connection status indicator visible but subtle (not distracting)
- Metrics refresh automatically without user intervention

## Success Criteria

- [x] Alert list updates in real-time when new alerts arrive
- [x] Alert detail view updates when status changes (multi-user)
- [x] Supabase subscriptions cleaned up properly (no memory leaks)
- [x] Metrics dashboard shows: agendamentos hoje, taxa de confirmação, conversas ativas
- [x] Service status indicators show: Evolution API, N8N, Supabase
- [x] All subscriptions unsubscribe on unmount
- [x] Build passes: `npm run build`

## Output

**Deliverables:**
1. Real-time helpers: src/lib/realtime/alerts.ts, src/lib/realtime/cleanup.ts
2. Updated alert list with real-time: src/app/dashboard/alerts/page.tsx
3. Updated alert detail with real-time: src/app/dashboard/alerts/[id]/page.tsx
4. Metrics dashboard: src/components/dashboard/metrics-dashboard.tsx
5. Service status: src/components/dashboard/service-status.tsx
6. Metrics API: src/lib/api/metrics.ts
7. Updated main dashboard with metrics/service status

**Next Steps:**
- Run E2E tests to verify all Phase 2 requirements
- User acceptance testing: Have atendente test alert workflow
- Phase 3: Patient Management (search, profiles, history)

**User Actions Required:**
1. Test real-time: Open two browser windows, verify alerts sync
2. Check service status: Ensure Evolution API and N8N URLs configured in .env.local
3. Verify metrics: Check if calculated values match expectations
