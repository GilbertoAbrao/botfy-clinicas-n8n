---
phase: 25-document-tool-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/agent/documentos/processar/route.ts
  - src/lib/document/url-fetcher.ts
autonomous: true

must_haves:
  truths:
    - "API accepts JSON requests with imageUrl parameter"
    - "API fetches images from HTTPS URLs"
    - "API blocks private network URLs (SSRF protection)"
    - "API validates fetched images with magic bytes (same as file uploads)"
  artifacts:
    - path: "src/lib/document/url-fetcher.ts"
      provides: "URL validation and secure image fetching"
      exports: ["fetchImageFromUrl", "validateImageUrl"]
    - path: "src/app/api/agent/documentos/processar/route.ts"
      provides: "Document processing with URL support"
      contains: "application/json"
  key_links:
    - from: "src/app/api/agent/documentos/processar/route.ts"
      to: "src/lib/document/url-fetcher.ts"
      via: "import fetchImageFromUrl"
      pattern: "fetchImageFromUrl"
    - from: "src/lib/document/url-fetcher.ts"
      to: "src/lib/document/document-validator.ts"
      via: "reuses MAX_FILE_SIZE constant"
      pattern: "MAX_FILE_SIZE"
---

<objective>
Enhance the document processing API to accept URL-based image input in addition to multipart uploads.

Purpose: N8N toolHttpRequest cannot easily send binary files. By accepting an imageUrl parameter, the AI Agent can pass document URLs directly and the API handles fetching.

Output: Updated API route that accepts both multipart/form-data (existing) and application/json with imageUrl (new).
</objective>

<execution_context>
@/Users/gilberto/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gilberto/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-document-tool-migration/25-RESEARCH.md
@src/app/api/agent/documentos/processar/route.ts
@src/lib/document/document-validator.ts
@src/lib/services/document-service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create URL Fetcher Utility</name>
  <files>src/lib/document/url-fetcher.ts</files>
  <action>
Create a new utility module for secure URL-based image fetching:

1. `validateImageUrl(url: string): URL` - Validates URL is safe to fetch:
   - Parse URL with `new URL(url)`
   - Only allow HTTPS protocol (reject http://, file://, etc.)
   - Block private IPs: localhost, 127.x.x.x, 10.x.x.x, 192.168.x.x, 172.16-31.x.x
   - Block common internal hostnames (localhost, *.local)
   - Throw descriptive error if validation fails

2. `fetchImageFromUrl(url: string): Promise<{ buffer: Buffer; filename: string; contentType: string }>` - Fetches image securely:
   - Call validateImageUrl first
   - Use AbortController with 10 second timeout
   - Check Content-Length header before download (reject if > MAX_FILE_SIZE from document-validator.ts)
   - Fetch with Accept: 'image/*,application/pdf' header
   - Return buffer, extracted filename from URL path, and Content-Type header
   - Throw descriptive errors for network failures, timeouts, size limits

Import MAX_FILE_SIZE from document-validator.ts to maintain single source of truth for size limit.

Do NOT use any external libraries - use native fetch with AbortController.
  </action>
  <verify>
File exists at src/lib/document/url-fetcher.ts with exported functions validateImageUrl and fetchImageFromUrl.
Run: `grep -E "export (async )?function (validateImageUrl|fetchImageFromUrl)" src/lib/document/url-fetcher.ts`
  </verify>
  <done>
URL fetcher utility created with SSRF protection and size limits.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update API Route for URL Input</name>
  <files>src/app/api/agent/documentos/processar/route.ts</files>
  <action>
Modify the POST handler to accept both multipart/form-data (existing) and application/json (new):

1. Check Content-Type header at start of handler
2. If `multipart/form-data`: Use existing formData parsing (unchanged)
3. If `application/json`: Parse JSON body with schema:
   ```typescript
   interface ProcessDocumentJsonBody {
     patientId: string
     imageUrl: string
     idempotencyKey?: string
   }
   ```
   - Validate patientId and imageUrl are present
   - Call fetchImageFromUrl to get buffer
   - Create a synthetic File object from buffer for the existing pipeline
   - Use filename from URL or default to 'document'

4. Rest of the processing (validation, extraction, storage) remains unchanged since we provide a File-like object

Key implementation detail: After fetching URL, create File object:
```typescript
const blob = new Blob([buffer], { type: contentType })
const file = new File([blob], filename, { type: contentType })
```

This allows reusing the entire existing pipeline without changes to document-service.ts.

Error responses:
- 400 for missing patientId or imageUrl
- 400 for invalid URL (SSRF blocked, not HTTPS)
- 400 for fetch failures (network error, timeout)
- 413 if remote file exceeds size limit
- 415 if Content-Type indicates unsupported type (let validator catch actual type)
  </action>
  <verify>
API handles JSON requests:
Run: `grep -c "application/json" src/app/api/agent/documentos/processar/route.ts` (should be >= 1)
Run: `grep "fetchImageFromUrl" src/app/api/agent/documentos/processar/route.ts` (should find import/usage)
  </verify>
  <done>
API accepts both multipart/form-data and application/json with imageUrl. Same validation, extraction, and storage pipeline for both.
  </done>
</task>

<task type="auto">
  <name>Task 3: Test API with curl</name>
  <files>N/A (testing only)</files>
  <action>
Test the enhanced API endpoint:

1. Start dev server if not running (check if port 3051 responds)

2. Test JSON endpoint (use a public test image URL):
```bash
# Test with a simple public image URL
curl -X POST "http://localhost:3051/api/agent/documentos/processar" \
  -H "Authorization: Bearer $AGENT_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{"patientId": "test-123", "imageUrl": "https://placehold.co/400x300.png"}'
```

Expected: Either success (if placehold.co works) or meaningful error about image processing.

3. Test SSRF protection:
```bash
# Should be blocked (private IP)
curl -X POST "http://localhost:3051/api/agent/documentos/processar" \
  -H "Authorization: Bearer $AGENT_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{"patientId": "test-123", "imageUrl": "http://127.0.0.1/image.png"}'
```

Expected: 400 error with "Only HTTPS URLs are allowed" or "Private network URLs are not allowed"

4. Verify multipart still works (existing functionality):
```bash
# Create a test image
echo "PNG" > /tmp/test.png
curl -X POST "http://localhost:3051/api/agent/documentos/processar" \
  -H "Authorization: Bearer $AGENT_API_KEY" \
  -F "file=@/tmp/test.png" \
  -F "patientId=test-123"
```

Expected: Error about invalid file type (test.png is not a real image), but NOT a 500 error.

Note: If AGENT_API_KEY is not set, you may need to check .env.local for the agent API key or skip auth testing.
  </action>
  <verify>
API responds to JSON requests without 500 errors. SSRF protection blocks private URLs.
  </verify>
  <done>
API enhancement tested and working for URL-based input.
  </done>
</task>

</tasks>

<verification>
- [ ] New file src/lib/document/url-fetcher.ts exists with validateImageUrl and fetchImageFromUrl
- [ ] API route handles Content-Type: application/json
- [ ] API fetches images from valid HTTPS URLs
- [ ] API blocks private network URLs (127.x, 10.x, 192.168.x, 172.16-31.x, localhost)
- [ ] API rejects non-HTTPS URLs
- [ ] API enforces 10 second timeout on URL fetches
- [ ] API rejects remote files > 5MB
- [ ] Existing multipart/form-data handling still works
- [ ] No TypeScript errors: `npx tsc --noEmit`
</verification>

<success_criteria>
1. POST /api/agent/documentos/processar accepts Content-Type: application/json
2. JSON body with {patientId, imageUrl} triggers URL fetch and processing
3. URL validation blocks SSRF attempts (private IPs, non-HTTPS)
4. Fetched images go through same validation pipeline as uploaded files
5. Existing multipart upload functionality unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/25-document-tool-migration/25-01-SUMMARY.md`
</output>
