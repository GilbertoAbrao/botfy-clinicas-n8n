---
phase: 18-query-tools
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/services/instruction-service.ts
  - src/app/api/agent/instrucoes/route.ts
autonomous: true

must_haves:
  truths:
    - "AI Agent can retrieve procedure instructions by service ID"
    - "AI Agent can retrieve instructions by instruction type"
    - "Instructions are returned ordered by priority"
  artifacts:
    - path: "src/lib/services/instruction-service.ts"
      provides: "Instruction search and retrieval"
      exports: ["searchInstructions", "InstructionQuery", "InstructionSearchResult"]
    - path: "src/app/api/agent/instrucoes/route.ts"
      provides: "GET /api/agent/instrucoes endpoint"
      exports: ["GET"]
  key_links:
    - from: "src/app/api/agent/instrucoes/route.ts"
      to: "src/lib/services/instruction-service.ts"
      via: "searchInstructions() service call"
      pattern: "searchInstructions\\("
    - from: "src/lib/services/instruction-service.ts"
      to: "prisma.procedureInstruction"
      via: "Prisma query with filters"
      pattern: "prisma\\.procedureInstruction\\.findMany"
---

<objective>
Implement the procedure instructions API for AI Agent to retrieve patient preparation instructions.

Purpose: Enables the N8N AI Agent to provide patients with relevant preparation instructions before their appointments.
Output: GET /api/agent/instrucoes endpoint with instruction-service.ts business logic.
</objective>

<execution_context>
@/Users/gilberto/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gilberto/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-query-tools/18-RESEARCH.md

# Phase 17 foundation
@src/lib/agent/types.ts
@src/lib/agent/middleware.ts
@src/lib/agent/error-handler.ts
@src/lib/validations/agent-schemas.ts

# Prisma schema
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create instruction-service.ts with search functionality</name>
  <files>src/lib/services/instruction-service.ts</files>
  <action>
Create instruction-service.ts with filtering by service and type:

```typescript
// src/lib/services/instruction-service.ts

import { prisma } from '@/lib/prisma'

export interface InstructionQuery {
  servicoId?: number
  tipoInstrucao?: string
}

export interface InstructionResult {
  id: number
  servicoId: number | null
  tipoInstrucao: string
  titulo: string
  conteudo: string
  prioridade: number
  servico?: {
    id: number
    nome: string
  }
}

export interface InstructionSearchResult {
  instrucoes: InstructionResult[]
  total: number
  filters: {
    servicoId?: number
    tipoInstrucao?: string
  }
}

// Instruction type categories for reference
export const INSTRUCTION_TYPES = [
  'jejum',           // Fasting instructions
  'hidratacao',      // Hydration instructions
  'medicamentos',    // Medication instructions
  'documentos',      // Document requirements
  'vestimenta',      // Clothing/preparation
  'acompanhante',    // Companion requirements
  'geral',           // General instructions
] as const

export async function searchInstructions(query: InstructionQuery): Promise<InstructionSearchResult> {
  // Build where clause
  const where: any = {
    ativo: true,  // Only active instructions
  }

  if (query.servicoId) {
    where.servicoId = query.servicoId
  }

  if (query.tipoInstrucao) {
    where.tipoInstrucao = {
      equals: query.tipoInstrucao,
      mode: 'insensitive',
    }
  }

  // Query with service info
  const instructions = await prisma.procedureInstruction.findMany({
    where,
    orderBy: [
      { prioridade: 'desc' },  // Higher priority first
      { tipoInstrucao: 'asc' }, // Then by type
    ],
    include: {
      servico: {
        select: {
          id: true,
          nome: true,
        },
      },
    },
  })

  // Transform to API response format
  const instrucoes: InstructionResult[] = instructions.map((inst) => ({
    id: inst.id,
    servicoId: inst.servicoId,
    tipoInstrucao: inst.tipoInstrucao,
    titulo: inst.titulo,
    conteudo: inst.conteudo,
    prioridade: inst.prioridade,
    servico: inst.servico
      ? {
          id: inst.servico.id,
          nome: inst.servico.nome,
        }
      : undefined,
  }))

  return {
    instrucoes,
    total: instrucoes.length,
    filters: {
      servicoId: query.servicoId,
      tipoInstrucao: query.tipoInstrucao,
    },
  }
}

/**
 * Get instructions for a specific appointment based on its service.
 * This is a convenience method for N8N workflows.
 */
export async function getInstructionsForAppointment(appointmentId: number): Promise<InstructionSearchResult> {
  // Get appointment's service
  const appointment = await prisma.appointment.findUnique({
    where: { id: appointmentId },
    select: { servicoId: true },
  })

  if (!appointment?.servicoId) {
    // No service linked - return general instructions
    return searchInstructions({ tipoInstrucao: 'geral' })
  }

  return searchInstructions({ servicoId: appointment.servicoId })
}
```

Key implementation details:
- Filters by servicoId and/or tipoInstrucao
- Only returns active instructions (ativo: true)
- Ordered by priority (descending) then type
- Includes service name for context
- Provides convenience method for appointment-based lookup
  </action>
  <verify>
Run TypeScript compilation:
```bash
npx tsc --noEmit src/lib/services/instruction-service.ts
```
Verify exports:
```bash
grep -E "^export (async function|interface|const)" src/lib/services/instruction-service.ts
```
  </verify>
  <done>
instruction-service.ts exists with searchInstructions(), InstructionQuery, InstructionSearchResult exports. TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create GET /api/agent/instrucoes route</name>
  <files>src/app/api/agent/instrucoes/route.ts</files>
  <action>
Create the API route with authentication and validation:

```typescript
// src/app/api/agent/instrucoes/route.ts

import { NextRequest } from 'next/server'
import { withAgentAuth } from '@/lib/agent/middleware'
import { successResponse, handleApiError } from '@/lib/agent/error-handler'
import { searchInstructions, INSTRUCTION_TYPES } from '@/lib/services/instruction-service'
import { agentInstructionsSearchSchema } from '@/lib/validations/agent-schemas'
import { logAudit, AuditAction } from '@/lib/audit/logger'

/**
 * GET /api/agent/instrucoes
 *
 * Search procedure instructions for patient preparation.
 *
 * Query parameters (all optional - returns all if none provided):
 * - servicoId (optional): Filter by service ID
 * - tipoInstrucao (optional): Filter by instruction type
 *
 * Instruction types: jejum, hidratacao, medicamentos, documentos, vestimenta, acompanhante, geral
 *
 * Response:
 * {
 *   success: true,
 *   data: {
 *     instrucoes: [
 *       {
 *         id: 1,
 *         servicoId: 5,
 *         tipoInstrucao: "jejum",
 *         titulo: "Jejum de 8 horas",
 *         conteudo: "Não consumir alimentos sólidos...",
 *         prioridade: 10,
 *         servico: { id: 5, nome: "Exame de Sangue" }
 *       },
 *       ...
 *     ],
 *     total: 5,
 *     filters: { servicoId: 5, tipoInstrucao: null },
 *     instructionTypes: ["jejum", "hidratacao", ...]  // Available types for reference
 *   }
 * }
 */
export const GET = withAgentAuth(async (req: NextRequest, context, agentContext) => {
  try {
    // 1. Parse and validate query parameters
    const searchParams = Object.fromEntries(req.nextUrl.searchParams)
    const query = agentInstructionsSearchSchema.parse(searchParams)

    // 2. Call service layer
    const result = await searchInstructions({
      servicoId: query.servicoId,
      tipoInstrucao: query.tipoInstrucao,
    })

    // 3. Audit log (fire and forget)
    logAudit({
      userId: agentContext.userId,
      action: AuditAction.AGENT_VIEW_INSTRUCTIONS,
      resource: 'agent_api',
      details: {
        agentId: agentContext.agentId,
        correlationId: agentContext.correlationId,
        filters: {
          servicoId: query.servicoId,
          tipoInstrucao: query.tipoInstrucao,
        },
        resultCount: result.total,
      },
    }).catch(console.error)

    // 4. Return success response with instruction types for reference
    return successResponse({
      ...result,
      instructionTypes: INSTRUCTION_TYPES,
    })
  } catch (error) {
    return handleApiError(error)
  }
})
```

Key implementation details:
- Uses `withAgentAuth()` HOF for Bearer token authentication
- Validates query params with `agentInstructionsSearchSchema` from Phase 17
- Calls `searchInstructions()` service function
- Includes available instruction types in response for AI reference
- Returns consistent `ApiResponse` format
  </action>
  <verify>
Run TypeScript compilation:
```bash
npx tsc --noEmit src/app/api/agent/instrucoes/route.ts
```
Verify GET export:
```bash
grep "^export const GET" src/app/api/agent/instrucoes/route.ts
```
  </verify>
  <done>
GET /api/agent/instrucoes route exists with authentication, validation, service call, and audit logging. TypeScript compiles without errors.
  </done>
</task>

</tasks>

<verification>
After completing both tasks:

1. TypeScript compilation passes:
```bash
npx tsc --noEmit
```

2. Service exports are correct:
```bash
grep -E "^export" src/lib/services/instruction-service.ts
```

3. Route exports GET handler:
```bash
grep "^export const GET" src/app/api/agent/instrucoes/route.ts
```

4. Service orders by priority:
```bash
grep "prioridade" src/lib/services/instruction-service.ts
```
</verification>

<success_criteria>
- [ ] src/lib/services/instruction-service.ts exists with searchInstructions()
- [ ] src/app/api/agent/instrucoes/route.ts exists with GET handler
- [ ] Service filters by servicoId and tipoInstrucao
- [ ] Service only returns active instructions
- [ ] Service orders by priority (descending)
- [ ] Route validates input with agentInstructionsSearchSchema
- [ ] Route logs audit with AGENT_VIEW_INSTRUCTIONS action
- [ ] Route includes INSTRUCTION_TYPES in response
- [ ] TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/18-query-tools/18-05-SUMMARY.md`
</output>
