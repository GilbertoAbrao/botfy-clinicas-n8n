---
phase: 18-query-tools
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/services/patient-service.ts
  - src/app/api/agent/paciente/route.ts
autonomous: true

must_haves:
  truths:
    - "AI Agent can find patient by phone number with exact or partial match"
    - "AI Agent can find patient by CPF"
    - "Response includes upcoming appointments for context"
  artifacts:
    - path: "src/lib/services/patient-service.ts"
      provides: "Patient search with exact/partial matching"
      exports: ["searchPatient", "PatientSearchQuery", "PatientSearchResult"]
    - path: "src/app/api/agent/paciente/route.ts"
      provides: "GET /api/agent/paciente endpoint"
      exports: ["GET"]
  key_links:
    - from: "src/app/api/agent/paciente/route.ts"
      to: "src/lib/services/patient-service.ts"
      via: "searchPatient() service call"
      pattern: "searchPatient\\("
    - from: "src/lib/services/patient-service.ts"
      to: "prisma.patient"
      via: "Prisma query with exact/partial match"
      pattern: "prisma\\.patient\\.(findUnique|findMany)"
---

<objective>
Implement the patient search API for AI Agent to find patient records by phone or CPF.

Purpose: Enables the N8N AI Agent to look up patient information when they call or message.
Output: GET /api/agent/paciente endpoint with patient-service.ts business logic.
</objective>

<execution_context>
@/Users/gilberto/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gilberto/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-query-tools/18-RESEARCH.md

# Phase 17 foundation
@src/lib/agent/types.ts
@src/lib/agent/middleware.ts
@src/lib/agent/error-handler.ts
@src/lib/validations/agent-schemas.ts

# Prisma schema
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create patient-service.ts with search functionality</name>
  <files>src/lib/services/patient-service.ts</files>
  <action>
Create patient-service.ts with exact and partial match support:

```typescript
// src/lib/services/patient-service.ts

import { prisma } from '@/lib/prisma'

export interface PatientSearchQuery {
  telefone?: string
  cpf?: string
  nome?: string
}

export interface PatientResult {
  id: number
  nome: string
  telefone: string
  email: string | null
  cpf: string | null
  dataNascimento: string | null  // YYYY-MM-DD
  convenio: string | null
  observacoes: string | null
}

export interface UpcomingAppointment {
  id: number
  dataHora: string  // ISO 8601
  tipoConsulta: string
  profissional: string | null
  status: string | null
}

export interface PatientSearchResult {
  patient: PatientResult | null
  patients?: PatientResult[]  // Only when partial match
  matchType: 'exact' | 'partial' | 'none'
  upcomingAppointments?: UpcomingAppointment[]
}

export async function searchPatient(query: PatientSearchQuery): Promise<PatientSearchResult> {
  // Validate at least one search param
  if (!query.telefone && !query.cpf && !query.nome) {
    throw new Error('At least one search parameter required (telefone, cpf, or nome)')
  }

  // Priority 1: Search by phone (most common for WhatsApp)
  if (query.telefone) {
    return searchByPhone(query.telefone)
  }

  // Priority 2: Search by CPF
  if (query.cpf) {
    return searchByCpf(query.cpf)
  }

  // Priority 3: Search by name (partial match only)
  if (query.nome) {
    return searchByName(query.nome)
  }

  return { patient: null, matchType: 'none' }
}

async function searchByPhone(telefone: string): Promise<PatientSearchResult> {
  // Normalize phone (remove non-digits)
  const normalizedPhone = telefone.replace(/\D/g, '')

  // Try exact match first (fast, indexed)
  const exactMatch = await prisma.patient.findUnique({
    where: { telefone: normalizedPhone },
  })

  if (exactMatch) {
    const upcomingAppointments = await getUpcomingAppointments(exactMatch.id)
    return {
      patient: formatPatient(exactMatch),
      matchType: 'exact',
      upcomingAppointments,
    }
  }

  // Fallback to partial match (slower, limit results)
  const partialMatches = await prisma.patient.findMany({
    where: {
      telefone: {
        contains: normalizedPhone,
        mode: 'insensitive',
      },
    },
    take: 10,
  })

  if (partialMatches.length === 1) {
    // Single partial match - treat as exact
    const upcomingAppointments = await getUpcomingAppointments(partialMatches[0].id)
    return {
      patient: formatPatient(partialMatches[0]),
      matchType: 'exact',
      upcomingAppointments,
    }
  }

  if (partialMatches.length > 1) {
    return {
      patient: null,
      patients: partialMatches.map(formatPatient),
      matchType: 'partial',
    }
  }

  return { patient: null, matchType: 'none' }
}

async function searchByCpf(cpf: string): Promise<PatientSearchResult> {
  // Normalize CPF (remove non-digits)
  const normalizedCpf = cpf.replace(/\D/g, '')

  const patient = await prisma.patient.findFirst({
    where: { cpf: normalizedCpf },
  })

  if (patient) {
    const upcomingAppointments = await getUpcomingAppointments(patient.id)
    return {
      patient: formatPatient(patient),
      matchType: 'exact',
      upcomingAppointments,
    }
  }

  return { patient: null, matchType: 'none' }
}

async function searchByName(nome: string): Promise<PatientSearchResult> {
  const patients = await prisma.patient.findMany({
    where: {
      nome: {
        contains: nome,
        mode: 'insensitive',
      },
    },
    take: 10,
  })

  if (patients.length === 1) {
    const upcomingAppointments = await getUpcomingAppointments(patients[0].id)
    return {
      patient: formatPatient(patients[0]),
      matchType: 'exact',
      upcomingAppointments,
    }
  }

  if (patients.length > 1) {
    return {
      patient: null,
      patients: patients.map(formatPatient),
      matchType: 'partial',
    }
  }

  return { patient: null, matchType: 'none' }
}

async function getUpcomingAppointments(patientId: number): Promise<UpcomingAppointment[]> {
  const now = new Date()

  const appointments = await prisma.appointment.findMany({
    where: {
      pacienteId: patientId,
      dataHora: { gte: now },
      status: {
        notIn: ['cancelada', 'faltou'],
      },
    },
    orderBy: { dataHora: 'asc' },
    take: 5,
    select: {
      id: true,
      dataHora: true,
      tipoConsulta: true,
      profissional: true,
      status: true,
    },
  })

  return appointments.map((apt) => ({
    id: apt.id,
    dataHora: apt.dataHora.toISOString(),
    tipoConsulta: apt.tipoConsulta,
    profissional: apt.profissional,
    status: apt.status,
  }))
}

function formatPatient(patient: any): PatientResult {
  return {
    id: patient.id,
    nome: patient.nome,
    telefone: patient.telefone,
    email: patient.email,
    cpf: patient.cpf,
    dataNascimento: patient.dataNascimento
      ? patient.dataNascimento.toISOString().split('T')[0]
      : null,
    convenio: patient.convenio,
    observacoes: patient.observacoes,
  }
}
```

Key implementation details:
- Exact match first (indexed, fast), then partial match fallback
- Normalizes phone/CPF by removing non-digits
- Single partial match treated as exact (common when user omits area code)
- Includes up to 5 upcoming appointments for AI context
- Limits partial match results to 10 to avoid large responses
  </action>
  <verify>
Run TypeScript compilation:
```bash
npx tsc --noEmit src/lib/services/patient-service.ts
```
Verify exports:
```bash
grep -E "^export (async function|interface)" src/lib/services/patient-service.ts
```
  </verify>
  <done>
patient-service.ts exists with searchPatient(), PatientSearchQuery, PatientSearchResult exports. TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create GET /api/agent/paciente route</name>
  <files>src/app/api/agent/paciente/route.ts</files>
  <action>
Create the API route with authentication and validation:

```typescript
// src/app/api/agent/paciente/route.ts

import { NextRequest } from 'next/server'
import { withAgentAuth } from '@/lib/agent/middleware'
import { successResponse, handleApiError, errorResponse } from '@/lib/agent/error-handler'
import { searchPatient } from '@/lib/services/patient-service'
import { agentPatientSearchSchema } from '@/lib/validations/agent-schemas'
import { logAudit, AuditAction } from '@/lib/audit/logger'

/**
 * GET /api/agent/paciente
 *
 * Search for a patient by phone, CPF, or name.
 *
 * Query parameters (at least one required):
 * - telefone (optional): Phone number (exact or partial match)
 * - cpf (optional): CPF number (exact match)
 * - nome (optional): Patient name (partial match)
 *
 * Response (exact match):
 * {
 *   success: true,
 *   data: {
 *     patient: { id, nome, telefone, ... },
 *     matchType: "exact",
 *     upcomingAppointments: [...]
 *   }
 * }
 *
 * Response (partial match - multiple results):
 * {
 *   success: true,
 *   data: {
 *     patient: null,
 *     patients: [{ id, nome, telefone, ... }, ...],
 *     matchType: "partial"
 *   }
 * }
 *
 * Response (not found):
 * {
 *   success: true,
 *   data: {
 *     patient: null,
 *     matchType: "none"
 *   }
 * }
 */
export const GET = withAgentAuth(async (req: NextRequest, context, agentContext) => {
  try {
    // 1. Parse and validate query parameters
    const searchParams = Object.fromEntries(req.nextUrl.searchParams)
    const query = agentPatientSearchSchema.parse(searchParams)

    // 2. Call service layer
    const result = await searchPatient({
      telefone: query.telefone,
      cpf: query.cpf,
      nome: query.nome,
    })

    // 3. Audit log (fire and forget)
    // Log search without exposing PHI in details
    logAudit({
      userId: agentContext.userId,
      action: AuditAction.AGENT_VIEW_PATIENT,
      resource: 'agent_api',
      resourceId: result.patient?.id?.toString(),
      details: {
        agentId: agentContext.agentId,
        correlationId: agentContext.correlationId,
        searchType: query.telefone ? 'phone' : query.cpf ? 'cpf' : 'name',
        matchType: result.matchType,
        resultCount: result.matchType === 'partial'
          ? result.patients?.length
          : result.patient ? 1 : 0,
      },
    }).catch(console.error)

    // 4. Return success response
    return successResponse(result)
  } catch (error) {
    return handleApiError(error)
  }
})
```

Key implementation details:
- Uses `withAgentAuth()` HOF for Bearer token authentication
- Validates query params with `agentPatientSearchSchema` from Phase 17
- Calls `searchPatient()` service function
- Does NOT expose PHI (telefone, cpf, nome) in audit logs
- Returns consistent `ApiResponse` format
- Returns matchType to help AI Agent understand result quality
  </action>
  <verify>
Run TypeScript compilation:
```bash
npx tsc --noEmit src/app/api/agent/paciente/route.ts
```
Verify GET export:
```bash
grep "^export const GET" src/app/api/agent/paciente/route.ts
```
  </verify>
  <done>
GET /api/agent/paciente route exists with authentication, validation, service call, and audit logging. TypeScript compiles without errors.
  </done>
</task>

</tasks>

<verification>
After completing both tasks:

1. TypeScript compilation passes:
```bash
npx tsc --noEmit
```

2. Service exports are correct:
```bash
grep -E "^export" src/lib/services/patient-service.ts
```

3. Route exports GET handler:
```bash
grep "^export const GET" src/app/api/agent/paciente/route.ts
```

4. Service implements exact and partial match:
```bash
grep -E "findUnique|findMany" src/lib/services/patient-service.ts
```
</verification>

<success_criteria>
- [ ] src/lib/services/patient-service.ts exists with searchPatient(), exact/partial match logic
- [ ] src/app/api/agent/paciente/route.ts exists with GET handler
- [ ] Service tries exact match first, falls back to partial
- [ ] Service normalizes phone/CPF input
- [ ] Service includes upcoming appointments for exact matches
- [ ] Route validates input with agentPatientSearchSchema
- [ ] Route logs audit with AGENT_VIEW_PATIENT action
- [ ] PHI is NOT exposed in audit logs
- [ ] TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/18-query-tools/18-03-SUMMARY.md`
</output>
