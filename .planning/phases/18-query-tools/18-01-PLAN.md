---
phase: 18-query-tools
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/services/slot-service.ts
  - src/app/api/agent/slots/route.ts
autonomous: true

must_haves:
  truths:
    - "AI Agent can retrieve available appointment slots for a specific date"
    - "AI Agent can filter slots by period (morning/afternoon/any)"
    - "Slots correctly exclude already-booked time blocks"
  artifacts:
    - path: "src/lib/services/slot-service.ts"
      provides: "Slot availability calculation"
      exports: ["getAvailableSlots", "SlotQuery", "SlotResult"]
    - path: "src/app/api/agent/slots/route.ts"
      provides: "GET /api/agent/slots endpoint"
      exports: ["GET"]
  key_links:
    - from: "src/app/api/agent/slots/route.ts"
      to: "src/lib/services/slot-service.ts"
      via: "getAvailableSlots() service call"
      pattern: "getAvailableSlots\\("
    - from: "src/lib/services/slot-service.ts"
      to: "src/lib/calendar/availability-calculator.ts"
      via: "calculateAvailableSlots() reuse"
      pattern: "calculateAvailableSlots\\("
---

<objective>
Implement the slots availability API for AI Agent to query available appointment time slots.

Purpose: Enables the N8N AI Agent to find open appointment slots when patients ask about availability.
Output: GET /api/agent/slots endpoint with slot-service.ts business logic.
</objective>

<execution_context>
@/Users/gilberto/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gilberto/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-query-tools/18-RESEARCH.md

# Phase 17 foundation (types, auth, error handling)
@src/lib/agent/types.ts
@src/lib/agent/middleware.ts
@src/lib/agent/error-handler.ts
@src/lib/validations/agent-schemas.ts

# Existing calendar utilities to reuse (DO NOT reimplement)
@src/lib/calendar/availability-calculator.ts
@src/lib/calendar/conflict-detection.ts
@src/lib/calendar/time-zone-utils.ts

# Prisma schema for database models
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create slot-service.ts with availability calculation</name>
  <files>src/lib/services/slot-service.ts</files>
  <action>
Create the services directory and slot-service.ts file:

```typescript
// src/lib/services/slot-service.ts

import { prisma } from '@/lib/prisma'
import { calculateAvailableSlots, DEFAULT_WORKING_HOURS, DEFAULT_BUFFER_MINUTES } from '@/lib/calendar/availability-calculator'
import { TimeSlot } from '@/lib/calendar/conflict-detection'
import { TZDate } from '@date-fns/tz'
import { startOfDay, endOfDay, format } from 'date-fns'

const CLINIC_TIMEZONE = 'America/Sao_Paulo'

export interface SlotQuery {
  date: TZDate
  profissional?: string
  servicoId?: number
  duracaoMinutos?: number
}

export interface SlotResult {
  date: string           // YYYY-MM-DD
  slots: string[]        // ["08:00", "09:00", ...]
  totalAvailable: number
  period: {
    morning: string[]    // Slots before 12:00
    afternoon: string[]  // Slots 12:00 and after
  }
}

export async function getAvailableSlots(query: SlotQuery): Promise<SlotResult> {
  const { date, profissional, servicoId, duracaoMinutos = 30 } = query

  // Get service duration if servicoId provided
  let appointmentDuration = duracaoMinutos
  if (servicoId) {
    const servico = await prisma.servico.findUnique({
      where: { id: servicoId },
      select: { duracaoMinutos: true },
    })
    if (servico) {
      appointmentDuration = servico.duracaoMinutos
    }
  }

  // Fetch existing appointments for the day
  const dayStart = startOfDay(date)
  const dayEnd = endOfDay(date)

  const where: any = {
    dataHora: {
      gte: dayStart,
      lte: dayEnd,
    },
    status: {
      notIn: ['cancelada', 'faltou'],
    },
  }

  if (profissional) {
    where.profissional = profissional
  }

  const appointments = await prisma.appointment.findMany({
    where,
    select: {
      id: true,
      dataHora: true,
      duracaoMinutos: true,
      profissional: true,
    },
  })

  // Convert to TimeSlot format for conflict detection
  const existingSlots: TimeSlot[] = appointments.map((apt) => {
    const start = new Date(apt.dataHora)
    const duration = apt.duracaoMinutos || 30
    const end = new Date(start.getTime() + duration * 60000)
    return {
      providerId: apt.profissional || 'default',
      start,
      end,
    }
  })

  // Calculate available slots using Phase 4 utility
  const availableSlots = calculateAvailableSlots(
    date,
    {
      providerId: profissional || 'default',
      workingHours: DEFAULT_WORKING_HOURS,
      appointmentDuration,
      bufferMinutes: DEFAULT_BUFFER_MINUTES,
    },
    existingSlots
  )

  // Format slots as HH:mm strings
  const formattedSlots = availableSlots.map((slot) =>
    format(slot, 'HH:mm')
  )

  // Split by morning/afternoon
  const morning = formattedSlots.filter((s) => parseInt(s.split(':')[0]) < 12)
  const afternoon = formattedSlots.filter((s) => parseInt(s.split(':')[0]) >= 12)

  return {
    date: format(date, 'yyyy-MM-dd'),
    slots: formattedSlots,
    totalAvailable: formattedSlots.length,
    period: {
      morning,
      afternoon,
    },
  }
}
```

Key implementation details:
- Reuses `calculateAvailableSlots()` from Phase 4 (DO NOT reimplement)
- Fetches existing appointments from database to find conflicts
- Excludes canceled and no-show appointments from conflict detection
- Returns slots formatted as HH:mm strings for easy N8N consumption
- Splits slots into morning/afternoon for period filtering
  </action>
  <verify>
Run TypeScript compilation:
```bash
npx tsc --noEmit src/lib/services/slot-service.ts
```
Verify exports exist:
```bash
grep -E "^export (async function|interface)" src/lib/services/slot-service.ts
```
  </verify>
  <done>
slot-service.ts exists with getAvailableSlots(), SlotQuery, and SlotResult exports. TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create GET /api/agent/slots route</name>
  <files>src/app/api/agent/slots/route.ts</files>
  <action>
Create the API route with authentication and validation:

```typescript
// src/app/api/agent/slots/route.ts

import { NextRequest } from 'next/server'
import { withAgentAuth } from '@/lib/agent/middleware'
import { successResponse, handleApiError } from '@/lib/agent/error-handler'
import { getAvailableSlots } from '@/lib/services/slot-service'
import { agentSlotsSearchSchema } from '@/lib/validations/agent-schemas'
import { logAudit, AuditAction } from '@/lib/audit/logger'

/**
 * GET /api/agent/slots
 *
 * Query available appointment slots for a specific date.
 *
 * Query parameters:
 * - data (required): Date in YYYY-MM-DD format
 * - profissional (optional): Filter by provider name
 * - servicoId (optional): Filter by service ID (to get correct duration)
 * - duracaoMinutos (optional): Override appointment duration (default: 30)
 *
 * Response:
 * {
 *   success: true,
 *   data: {
 *     date: "2026-01-25",
 *     slots: ["08:00", "09:00", "10:00", ...],
 *     totalAvailable: 12,
 *     period: {
 *       morning: ["08:00", "09:00", ...],
 *       afternoon: ["14:00", "15:00", ...]
 *     }
 *   }
 * }
 */
export const GET = withAgentAuth(async (req: NextRequest, context, agentContext) => {
  try {
    // 1. Parse and validate query parameters
    const searchParams = Object.fromEntries(req.nextUrl.searchParams)
    const query = agentSlotsSearchSchema.parse(searchParams)

    // 2. Call service layer
    const result = await getAvailableSlots({
      date: query.data,
      profissional: query.profissional,
      servicoId: query.servicoId,
      duracaoMinutos: query.duracaoMinutos,
    })

    // 3. Audit log (fire and forget)
    logAudit({
      userId: agentContext.userId,
      action: AuditAction.AGENT_SEARCH_SLOTS,
      resource: 'agent_api',
      details: {
        agentId: agentContext.agentId,
        correlationId: agentContext.correlationId,
        query: {
          date: query.data.toISOString(),
          profissional: query.profissional,
          servicoId: query.servicoId,
        },
        resultCount: result.totalAvailable,
      },
    }).catch(console.error) // Fire and forget

    // 4. Return success response
    return successResponse(result)
  } catch (error) {
    return handleApiError(error)
  }
})
```

Key implementation details:
- Uses `withAgentAuth()` HOF for Bearer token authentication
- Validates query params with `agentSlotsSearchSchema` from Phase 17
- Calls `getAvailableSlots()` service function
- Logs audit with `AGENT_SEARCH_SLOTS` action (fire and forget)
- Returns consistent `ApiResponse` format
  </action>
  <verify>
Run TypeScript compilation:
```bash
npx tsc --noEmit src/app/api/agent/slots/route.ts
```
Verify GET export exists:
```bash
grep "^export const GET" src/app/api/agent/slots/route.ts
```
  </verify>
  <done>
GET /api/agent/slots route exists with authentication, validation, service call, and audit logging. TypeScript compiles without errors.
  </done>
</task>

</tasks>

<verification>
After completing both tasks:

1. TypeScript compilation passes:
```bash
npx tsc --noEmit
```

2. Service exports are correct:
```bash
grep -E "^export" src/lib/services/slot-service.ts
```

3. Route exports GET handler:
```bash
grep "^export const GET" src/app/api/agent/slots/route.ts
```

4. Service imports calendar utilities (not reimplementing):
```bash
grep "calculateAvailableSlots" src/lib/services/slot-service.ts
```
</verification>

<success_criteria>
- [ ] src/lib/services/slot-service.ts exists with getAvailableSlots(), SlotQuery, SlotResult
- [ ] src/app/api/agent/slots/route.ts exists with GET handler wrapped in withAgentAuth()
- [ ] Service reuses calculateAvailableSlots() from Phase 4 calendar utilities
- [ ] Route validates input with agentSlotsSearchSchema
- [ ] Route logs audit with AGENT_SEARCH_SLOTS action
- [ ] TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/18-query-tools/18-01-SUMMARY.md`
</output>
