---
phase: 18-query-tools
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/services/pre-checkin-service.ts
  - src/app/api/agent/pre-checkin/status/route.ts
autonomous: true

must_haves:
  truths:
    - "AI Agent can check pre-checkin status by appointment ID, patient ID, or phone"
    - "Response includes document status and pending items"
    - "Pre-checkin data is fetched via Supabase client (RLS table)"
  artifacts:
    - path: "src/lib/services/pre-checkin-service.ts"
      provides: "Pre-checkin status aggregation"
      exports: ["getPreCheckinStatus", "PreCheckinQuery", "PreCheckinStatusResult"]
    - path: "src/app/api/agent/pre-checkin/status/route.ts"
      provides: "GET /api/agent/pre-checkin/status endpoint"
      exports: ["GET"]
  key_links:
    - from: "src/app/api/agent/pre-checkin/status/route.ts"
      to: "src/lib/services/pre-checkin-service.ts"
      via: "getPreCheckinStatus() service call"
      pattern: "getPreCheckinStatus\\("
    - from: "src/lib/services/pre-checkin-service.ts"
      to: "supabase.from('pre_checkin')"
      via: "Supabase client query (RLS)"
      pattern: "\\.from\\('pre_checkin'\\)"
---

<objective>
Implement the pre-checkin status API for AI Agent to check patient document submission status.

Purpose: Enables the N8N AI Agent to tell patients about their pre-checkin progress and pending documents.
Output: GET /api/agent/pre-checkin/status endpoint with pre-checkin-service.ts business logic.
</objective>

<execution_context>
@/Users/gilberto/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gilberto/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-query-tools/18-RESEARCH.md

# Phase 17 foundation
@src/lib/agent/types.ts
@src/lib/agent/middleware.ts
@src/lib/agent/error-handler.ts
@src/lib/validations/agent-schemas.ts

# Supabase client for RLS tables
@src/lib/supabase/server.ts

# Prisma schema (for patient lookup by phone)
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pre-checkin-service.ts with status aggregation</name>
  <files>src/lib/services/pre-checkin-service.ts</files>
  <action>
Create pre-checkin-service.ts using Supabase client (pre_checkin has RLS):

```typescript
// src/lib/services/pre-checkin-service.ts

import { createAdminSupabaseClient } from '@/lib/supabase/admin'
import { prisma } from '@/lib/prisma'

export interface PreCheckinQuery {
  agendamentoId?: number
  pacienteId?: number
  telefone?: string
}

export interface PreCheckinStatusResult {
  exists: boolean
  status: string  // 'pendente', 'parcial', 'completo', 'rejeitado'
  agendamentoId?: number
  dadosConfirmados: boolean
  documentosEnviados: boolean
  instrucoesEnviadas: boolean
  pendencias: string[] | null
  mensagemEnviadaEm: string | null  // ISO 8601
  lembreteEnviadoEm: string | null  // ISO 8601
  appointment?: {
    dataHora: string
    tipoConsulta: string
    profissional: string | null
  }
}

export async function getPreCheckinStatus(query: PreCheckinQuery): Promise<PreCheckinStatusResult> {
  // Validate at least one search param
  if (!query.agendamentoId && !query.pacienteId && !query.telefone) {
    throw new Error('At least one parameter required (agendamentoId, pacienteId, or telefone)')
  }

  let appointmentId = query.agendamentoId

  // If searching by phone or patient ID, find the next upcoming appointment
  if (!appointmentId && (query.pacienteId || query.telefone)) {
    const appointment = await findNextAppointment(query.pacienteId, query.telefone)
    if (!appointment) {
      return {
        exists: false,
        status: 'pendente',
        dadosConfirmados: false,
        documentosEnviados: false,
        instrucoesEnviadas: false,
        pendencias: null,
        mensagemEnviadaEm: null,
        lembreteEnviadaEm: null,
      }
    }
    appointmentId = appointment.id
  }

  // Query pre_checkin via Supabase admin client (bypasses RLS for agent access)
  const supabase = createAdminSupabaseClient()

  const { data, error } = await supabase
    .from('pre_checkin')
    .select(`
      id,
      status,
      dados_confirmados,
      documentos_enviados,
      instrucoes_enviadas,
      pendencias,
      mensagem_enviada_em,
      lembrete_enviado_em
    `)
    .eq('agendamento_id', appointmentId)
    .single()

  // Get appointment details for context
  const appointment = await prisma.appointment.findUnique({
    where: { id: appointmentId! },
    select: {
      dataHora: true,
      tipoConsulta: true,
      profissional: true,
    },
  })

  if (error) {
    if (error.code === 'PGRST116') {
      // No pre-checkin record yet - return pending status
      return {
        exists: false,
        status: 'pendente',
        agendamentoId: appointmentId,
        dadosConfirmados: false,
        documentosEnviados: false,
        instrucoesEnviadas: false,
        pendencias: null,
        mensagemEnviadaEm: null,
        lembreteEnviadaEm: null,
        appointment: appointment
          ? {
              dataHora: appointment.dataHora.toISOString(),
              tipoConsulta: appointment.tipoConsulta,
              profissional: appointment.profissional,
            }
          : undefined,
      }
    }
    throw error
  }

  return {
    exists: true,
    status: data.status,
    agendamentoId: appointmentId,
    dadosConfirmados: data.dados_confirmados ?? false,
    documentosEnviados: data.documentos_enviados ?? false,
    instrucoesEnviadas: data.instrucoes_enviadas ?? false,
    pendencias: data.pendencias,
    mensagemEnviadaEm: data.mensagem_enviada_em,
    lembreteEnviadaEm: data.lembrete_enviado_em,
    appointment: appointment
      ? {
          dataHora: appointment.dataHora.toISOString(),
          tipoConsulta: appointment.tipoConsulta,
          profissional: appointment.profissional,
        }
      : undefined,
  }
}

async function findNextAppointment(
  pacienteId?: number,
  telefone?: string
): Promise<{ id: number } | null> {
  const now = new Date()

  // Build where clause
  const where: any = {
    dataHora: { gte: now },
    status: { notIn: ['cancelada', 'faltou'] },
  }

  if (pacienteId) {
    where.pacienteId = pacienteId
  } else if (telefone) {
    // Find patient by phone first
    const normalizedPhone = telefone.replace(/\D/g, '')
    const patient = await prisma.patient.findUnique({
      where: { telefone: normalizedPhone },
      select: { id: true },
    })

    if (!patient) {
      return null
    }

    where.pacienteId = patient.id
  }

  const appointment = await prisma.appointment.findFirst({
    where,
    orderBy: { dataHora: 'asc' },
    select: { id: true },
  })

  return appointment
}
```

Key implementation details:
- Uses Supabase admin client for pre_checkin (RLS table)
- Uses Prisma for appointment lookup (better types)
- Finds next upcoming appointment if searching by patient/phone
- Returns appointment details for AI context
- Handles case where no pre-checkin record exists yet (returns 'pendente')
  </action>
  <verify>
Run TypeScript compilation:
```bash
npx tsc --noEmit src/lib/services/pre-checkin-service.ts
```
Verify exports:
```bash
grep -E "^export (async function|interface)" src/lib/services/pre-checkin-service.ts
```
  </verify>
  <done>
pre-checkin-service.ts exists with getPreCheckinStatus(), PreCheckinQuery, PreCheckinStatusResult exports. TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create GET /api/agent/pre-checkin/status route</name>
  <files>src/app/api/agent/pre-checkin/status/route.ts</files>
  <action>
Create the API route with authentication and validation:

```typescript
// src/app/api/agent/pre-checkin/status/route.ts

import { NextRequest } from 'next/server'
import { withAgentAuth } from '@/lib/agent/middleware'
import { successResponse, handleApiError } from '@/lib/agent/error-handler'
import { getPreCheckinStatus } from '@/lib/services/pre-checkin-service'
import { agentPreCheckinStatusSchema } from '@/lib/validations/agent-schemas'
import { logAudit, AuditAction } from '@/lib/audit/logger'

/**
 * GET /api/agent/pre-checkin/status
 *
 * Check pre-checkin status for an appointment.
 *
 * Query parameters (at least one required):
 * - agendamentoId (optional): Direct appointment ID lookup
 * - pacienteId (optional): Find next appointment for patient
 * - telefone (optional): Find next appointment by phone
 *
 * Response:
 * {
 *   success: true,
 *   data: {
 *     exists: true,
 *     status: "parcial",
 *     agendamentoId: 123,
 *     dadosConfirmados: true,
 *     documentosEnviados: false,
 *     instrucoesEnviadas: true,
 *     pendencias: ["RG", "Comprovante de residÃªncia"],
 *     mensagemEnviadaEm: "2026-01-24T10:00:00Z",
 *     lembreteEnviadaEm: null,
 *     appointment: {
 *       dataHora: "2026-01-25T14:00:00Z",
 *       tipoConsulta: "Consulta",
 *       profissional: "Dr. Maria"
 *     }
 *   }
 * }
 */
export const GET = withAgentAuth(async (req: NextRequest, context, agentContext) => {
  try {
    // 1. Parse and validate query parameters
    const searchParams = Object.fromEntries(req.nextUrl.searchParams)
    const query = agentPreCheckinStatusSchema.parse(searchParams)

    // 2. Call service layer
    const result = await getPreCheckinStatus({
      agendamentoId: query.agendamentoId,
      pacienteId: query.pacienteId,
      telefone: query.telefone,
    })

    // 3. Audit log (fire and forget)
    logAudit({
      userId: agentContext.userId,
      action: AuditAction.AGENT_VIEW_PRE_CHECKIN,
      resource: 'agent_api',
      resourceId: result.agendamentoId?.toString(),
      details: {
        agentId: agentContext.agentId,
        correlationId: agentContext.correlationId,
        searchType: query.agendamentoId
          ? 'appointment'
          : query.pacienteId
            ? 'patient'
            : 'phone',
        preCheckinStatus: result.status,
        exists: result.exists,
      },
    }).catch(console.error)

    // 4. Return success response
    return successResponse(result)
  } catch (error) {
    return handleApiError(error)
  }
})
```

Key implementation details:
- Uses `withAgentAuth()` HOF for Bearer token authentication
- Validates query params with `agentPreCheckinStatusSchema` from Phase 17
- Calls `getPreCheckinStatus()` service function
- Does NOT expose PHI (telefone) in audit logs
- Returns consistent `ApiResponse` format
  </action>
  <verify>
Run TypeScript compilation:
```bash
npx tsc --noEmit src/app/api/agent/pre-checkin/status/route.ts
```
Verify GET export:
```bash
grep "^export const GET" src/app/api/agent/pre-checkin/status/route.ts
```
  </verify>
  <done>
GET /api/agent/pre-checkin/status route exists with authentication, validation, service call, and audit logging. TypeScript compiles without errors.
  </done>
</task>

</tasks>

<verification>
After completing both tasks:

1. TypeScript compilation passes:
```bash
npx tsc --noEmit
```

2. Service exports are correct:
```bash
grep -E "^export" src/lib/services/pre-checkin-service.ts
```

3. Route exports GET handler:
```bash
grep "^export const GET" src/app/api/agent/pre-checkin/status/route.ts
```

4. Service uses Supabase for pre_checkin:
```bash
grep "from('pre_checkin')" src/lib/services/pre-checkin-service.ts
```
</verification>

<success_criteria>
- [ ] src/lib/services/pre-checkin-service.ts exists with getPreCheckinStatus()
- [ ] src/app/api/agent/pre-checkin/status/route.ts exists with GET handler
- [ ] Service uses Supabase admin client for pre_checkin (RLS table)
- [ ] Service uses Prisma for appointment lookup
- [ ] Service finds next upcoming appointment when searching by patient/phone
- [ ] Route validates input with agentPreCheckinStatusSchema
- [ ] Route logs audit with AGENT_VIEW_PRE_CHECKIN action
- [ ] TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/18-query-tools/18-04-SUMMARY.md`
</output>
