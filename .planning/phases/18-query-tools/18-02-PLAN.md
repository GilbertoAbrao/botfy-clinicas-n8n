---
phase: 18-query-tools
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/services/appointment-service.ts
  - src/app/api/agent/agendamentos/route.ts
autonomous: true

must_haves:
  truths:
    - "AI Agent can search appointments by patient, date range, status, or service"
    - "Appointments are paginated with page/limit parameters"
    - "Response includes patient name and phone for context"
  artifacts:
    - path: "src/lib/services/appointment-service.ts"
      provides: "Appointment search with pagination"
      exports: ["searchAppointments", "AppointmentQuery", "AppointmentSearchResult"]
    - path: "src/app/api/agent/agendamentos/route.ts"
      provides: "GET /api/agent/agendamentos endpoint"
      exports: ["GET"]
  key_links:
    - from: "src/app/api/agent/agendamentos/route.ts"
      to: "src/lib/services/appointment-service.ts"
      via: "searchAppointments() service call"
      pattern: "searchAppointments\\("
    - from: "src/lib/services/appointment-service.ts"
      to: "prisma.appointment"
      via: "Prisma query with pagination"
      pattern: "prisma\\.appointment\\.findMany"
---

<objective>
Implement the appointments search API for AI Agent to query patient appointments with filters and pagination.

Purpose: Enables the N8N AI Agent to find appointments when patients ask about their scheduled visits.
Output: GET /api/agent/agendamentos endpoint with appointment-service.ts business logic.
</objective>

<execution_context>
@/Users/gilberto/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gilberto/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-query-tools/18-RESEARCH.md

# Phase 17 foundation
@src/lib/agent/types.ts
@src/lib/agent/middleware.ts
@src/lib/agent/error-handler.ts
@src/lib/validations/agent-schemas.ts

# Prisma schema
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create appointment-service.ts with search and pagination</name>
  <files>src/lib/services/appointment-service.ts</files>
  <action>
Create appointment-service.ts with paginated search:

```typescript
// src/lib/services/appointment-service.ts

import { prisma } from '@/lib/prisma'
import { format } from 'date-fns'
import { TZDate } from '@date-fns/tz'

export interface AppointmentQuery {
  pacienteId?: number
  telefone?: string
  dataInicio?: TZDate
  dataFim?: TZDate
  status?: string
  servicoId?: number
  tipoConsulta?: string
  profissional?: string
  page?: number
  limit?: number
}

export interface AppointmentResult {
  id: number
  dataHora: string           // ISO 8601
  tipoConsulta: string
  profissional: string | null
  status: string | null
  observacoes: string | null
  paciente: {
    id: number
    nome: string
    telefone: string
  }
}

export interface PaginationMeta {
  page: number
  limit: number
  total: number
  totalPages: number
}

export interface AppointmentSearchResult {
  agendamentos: AppointmentResult[]
  pagination: PaginationMeta
}

export async function searchAppointments(query: AppointmentQuery): Promise<AppointmentSearchResult> {
  const page = query.page || 1
  const limit = Math.min(query.limit || 20, 100) // Max 100 per page
  const skip = (page - 1) * limit

  // Build where clause dynamically
  const where: any = {}

  // Filter by patient ID directly
  if (query.pacienteId) {
    where.pacienteId = query.pacienteId
  }

  // Filter by patient phone (requires join)
  if (query.telefone) {
    where.paciente = {
      telefone: {
        contains: query.telefone,
        mode: 'insensitive',
      },
    }
  }

  // Date range filters
  if (query.dataInicio || query.dataFim) {
    where.dataHora = {}
    if (query.dataInicio) {
      where.dataHora.gte = query.dataInicio
    }
    if (query.dataFim) {
      where.dataHora.lte = query.dataFim
    }
  }

  // Status filter
  if (query.status) {
    where.status = query.status
  }

  // Service filters
  if (query.servicoId) {
    where.servicoId = query.servicoId
  }
  if (query.tipoConsulta) {
    where.tipoConsulta = {
      contains: query.tipoConsulta,
      mode: 'insensitive',
    }
  }

  // Provider filter
  if (query.profissional) {
    where.profissional = {
      contains: query.profissional,
      mode: 'insensitive',
    }
  }

  // Execute count and find in parallel
  const [appointments, total] = await Promise.all([
    prisma.appointment.findMany({
      where,
      skip,
      take: limit,
      orderBy: { dataHora: 'asc' },
      include: {
        paciente: {
          select: {
            id: true,
            nome: true,
            telefone: true,
          },
        },
      },
    }),
    prisma.appointment.count({ where }),
  ])

  // Transform to API response format
  const agendamentos: AppointmentResult[] = appointments.map((apt) => ({
    id: apt.id,
    dataHora: apt.dataHora.toISOString(),
    tipoConsulta: apt.tipoConsulta,
    profissional: apt.profissional,
    status: apt.status,
    observacoes: apt.observacoes,
    paciente: {
      id: apt.paciente.id,
      nome: apt.paciente.nome,
      telefone: apt.paciente.telefone,
    },
  }))

  return {
    agendamentos,
    pagination: {
      page,
      limit,
      total,
      totalPages: Math.ceil(total / limit),
    },
  }
}
```

Key implementation details:
- Page-based pagination with default 20, max 100 per page
- Parallel count and find queries for efficiency
- Case-insensitive partial matching for telefone, tipoConsulta, profissional
- Includes patient name and phone in response for AI context
- Returns ISO 8601 date strings for consistent parsing
  </action>
  <verify>
Run TypeScript compilation:
```bash
npx tsc --noEmit src/lib/services/appointment-service.ts
```
Verify exports:
```bash
grep -E "^export (async function|interface)" src/lib/services/appointment-service.ts
```
  </verify>
  <done>
appointment-service.ts exists with searchAppointments(), AppointmentQuery, AppointmentSearchResult exports. TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create GET /api/agent/agendamentos route</name>
  <files>src/app/api/agent/agendamentos/route.ts</files>
  <action>
Create the API route with authentication and validation:

```typescript
// src/app/api/agent/agendamentos/route.ts

import { NextRequest } from 'next/server'
import { withAgentAuth } from '@/lib/agent/middleware'
import { successResponse, handleApiError } from '@/lib/agent/error-handler'
import { searchAppointments } from '@/lib/services/appointment-service'
import { agentAppointmentSearchSchema } from '@/lib/validations/agent-schemas'
import { logAudit, AuditAction } from '@/lib/audit/logger'

/**
 * GET /api/agent/agendamentos
 *
 * Search appointments with filters and pagination.
 *
 * Query parameters:
 * - pacienteId (optional): Filter by patient ID
 * - telefone (optional): Filter by patient phone (partial match)
 * - dataInicio (optional): Start date (ISO 8601)
 * - dataFim (optional): End date (ISO 8601)
 * - status (optional): Filter by status (agendada, confirmada, presente, cancelada, faltou)
 * - servicoId (optional): Filter by service ID
 * - tipoConsulta (optional): Filter by appointment type (partial match)
 * - profissional (optional): Filter by provider name (partial match)
 * - page (optional): Page number (default: 1)
 * - limit (optional): Items per page (default: 20, max: 100)
 *
 * Response:
 * {
 *   success: true,
 *   data: {
 *     agendamentos: [...],
 *     pagination: { page, limit, total, totalPages }
 *   }
 * }
 */
export const GET = withAgentAuth(async (req: NextRequest, context, agentContext) => {
  try {
    // 1. Parse and validate query parameters
    const searchParams = Object.fromEntries(req.nextUrl.searchParams)
    const query = agentAppointmentSearchSchema.parse(searchParams)

    // 2. Call service layer
    const result = await searchAppointments({
      pacienteId: query.pacienteId,
      telefone: query.telefone,
      dataInicio: query.dataInicio,
      dataFim: query.dataFim,
      status: query.status,
      servicoId: query.servicoId,
      tipoConsulta: query.tipoConsulta,
      profissional: query.profissional,
      page: query.page,
      limit: query.limit,
    })

    // 3. Audit log (fire and forget)
    logAudit({
      userId: agentContext.userId,
      action: AuditAction.AGENT_VIEW_APPOINTMENTS,
      resource: 'agent_api',
      details: {
        agentId: agentContext.agentId,
        correlationId: agentContext.correlationId,
        query: {
          pacienteId: query.pacienteId,
          telefone: query.telefone ? '***' : undefined, // Mask PHI
          dateRange: query.dataInicio || query.dataFim ? 'provided' : undefined,
          status: query.status,
        },
        resultCount: result.pagination.total,
        pageReturned: result.pagination.page,
      },
    }).catch(console.error)

    // 4. Return success response
    return successResponse(result)
  } catch (error) {
    return handleApiError(error)
  }
})
```

Key implementation details:
- Uses `withAgentAuth()` HOF for Bearer token authentication
- Validates query params with `agentAppointmentSearchSchema` from Phase 17
- Calls `searchAppointments()` service function
- Masks PHI (telefone) in audit logs
- Returns consistent `ApiResponse` format with pagination metadata
  </action>
  <verify>
Run TypeScript compilation:
```bash
npx tsc --noEmit src/app/api/agent/agendamentos/route.ts
```
Verify GET export:
```bash
grep "^export const GET" src/app/api/agent/agendamentos/route.ts
```
  </verify>
  <done>
GET /api/agent/agendamentos route exists with authentication, validation, service call, and audit logging. TypeScript compiles without errors.
  </done>
</task>

</tasks>

<verification>
After completing both tasks:

1. TypeScript compilation passes:
```bash
npx tsc --noEmit
```

2. Service exports are correct:
```bash
grep -E "^export" src/lib/services/appointment-service.ts
```

3. Route exports GET handler:
```bash
grep "^export const GET" src/app/api/agent/agendamentos/route.ts
```

4. Service uses Prisma pagination:
```bash
grep -E "skip|take" src/lib/services/appointment-service.ts
```
</verification>

<success_criteria>
- [ ] src/lib/services/appointment-service.ts exists with searchAppointments(), pagination
- [ ] src/app/api/agent/agendamentos/route.ts exists with GET handler
- [ ] Service implements page-based pagination (skip/take)
- [ ] Service includes patient info (nome, telefone) in response
- [ ] Route validates input with agentAppointmentSearchSchema
- [ ] Route logs audit with AGENT_VIEW_APPOINTMENTS action
- [ ] PHI is masked in audit logs
- [ ] TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/18-query-tools/18-02-SUMMARY.md`
</output>
