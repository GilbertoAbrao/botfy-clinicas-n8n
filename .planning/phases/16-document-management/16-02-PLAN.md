---
phase: 16-document-management
plan: 02
type: execute
wave: 2
depends_on: ["16-01"]
files_modified:
  - src/app/api/patient-documents/route.ts
  - src/app/api/patient-documents/[id]/approve/route.ts
  - src/app/api/patient-documents/[id]/reject/route.ts
  - src/app/api/patient-documents/[id]/preview/route.ts
  - src/app/api/patient-documents/bulk/route.ts
autonomous: true

must_haves:
  truths:
    - "GET /api/patient-documents returns paginated list with joined patient data"
    - "POST /api/patient-documents/[id]/approve updates validado=true and logs audit"
    - "POST /api/patient-documents/[id]/reject updates validado=false with required reason"
    - "GET /api/patient-documents/[id]/preview returns signed URL"
    - "POST /api/patient-documents/bulk handles bulk approve/reject"
  artifacts:
    - path: "src/app/api/patient-documents/route.ts"
      provides: "GET endpoint for document list with filters and pagination"
      exports: ["GET"]
    - path: "src/app/api/patient-documents/[id]/approve/route.ts"
      provides: "POST endpoint for approving single document"
      exports: ["POST"]
    - path: "src/app/api/patient-documents/[id]/reject/route.ts"
      provides: "POST endpoint for rejecting single document"
      exports: ["POST"]
    - path: "src/app/api/patient-documents/[id]/preview/route.ts"
      provides: "GET endpoint for signed URL"
      exports: ["GET"]
    - path: "src/app/api/patient-documents/bulk/route.ts"
      provides: "POST endpoint for bulk actions"
      exports: ["POST"]
  key_links:
    - from: "src/app/api/patient-documents/route.ts"
      to: "supabase.documentos_paciente"
      via: "Supabase client query"
      pattern: "from\\('documentos_paciente'\\)"
    - from: "src/app/api/patient-documents/[id]/preview/route.ts"
      to: "supabase.storage.patient-documents"
      via: "createSignedUrl"
      pattern: "createSignedUrl"
---

<objective>
Create API routes for document management: list with filters/pagination, approve/reject actions, preview signed URL generation, and bulk operations.

Purpose: Backend endpoints that the document management dashboard will consume.
Output: Complete API layer for CRUD operations on patient documents.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-document-management/16-01-SUMMARY.md
@src/app/api/pre-checkin/route.ts
@src/app/api/pacientes/[id]/documents/[docId]/route.ts
@src/lib/supabase/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GET /api/patient-documents endpoint</name>
  <files>src/app/api/patient-documents/route.ts</files>
  <action>
Create API route following pre-checkin pattern. Key differences:
- Uses Supabase client (not Prisma) since documentos_paciente is a Supabase table
- Includes status counts for filter badges

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { getCurrentUserWithRole } from '@/lib/auth/session'
import { logAudit, AuditAction } from '@/lib/audit/logger'
import { createServerSupabaseClient } from '@/lib/supabase/server'
import {
  patientDocumentFiltersSchema,
  getDocumentStatus,
  PatientDocument,
} from '@/lib/validations/patient-document'

export async function GET(req: NextRequest) {
  try {
    // 1. Auth check
    const user = await getCurrentUserWithRole()
    if (!user) {
      return NextResponse.json({ error: 'Nao autenticado' }, { status: 401 })
    }
    if (!['ADMIN', 'ATENDENTE'].includes(user.role)) {
      return NextResponse.json({ error: 'Sem permissao' }, { status: 403 })
    }

    // 2. Parse and validate query params
    const { searchParams } = new URL(req.url)
    const queryParams = Object.fromEntries(searchParams.entries())
    const filters = patientDocumentFiltersSchema.parse(queryParams)

    // 3. Build Supabase query
    const supabase = await createServerSupabaseClient()

    // Base query with patient join
    let query = supabase
      .from('documentos_paciente')
      .select(`
        *,
        paciente:pacientes!documentos_paciente_paciente_id_fkey (
          id,
          nome,
          telefone
        )
      `, { count: 'exact' })

    // 4. Apply filters
    // Status filter: map status string to validado boolean
    if (filters.status) {
      if (filters.status === 'pendente') {
        query = query.is('validado', null)
      } else if (filters.status === 'aprovado') {
        query = query.eq('validado', true)
      } else if (filters.status === 'rejeitado') {
        query = query.eq('validado', false)
      }
    }

    // Type filter
    if (filters.tipo) {
      query = query.eq('tipo', filters.tipo)
    }

    // Date range filter
    if (filters.dateStart) {
      query = query.gte('created_at', filters.dateStart)
    }
    if (filters.dateEnd) {
      query = query.lte('created_at', filters.dateEnd + 'T23:59:59')
    }

    // 5. Order and paginate
    query = query
      .order('created_at', { ascending: false })
      .range(
        (filters.page - 1) * filters.limit,
        filters.page * filters.limit - 1
      )

    const { data, error, count } = await query

    if (error) {
      console.error('[patient-documents] Supabase error:', error)
      throw new Error(error.message)
    }

    // 6. Client-side search filter (Supabase can't filter on joined fields)
    let filteredData = data || []
    if (filters.search && filteredData.length > 0) {
      const searchLower = filters.search.toLowerCase()
      filteredData = filteredData.filter((doc: any) =>
        doc.paciente?.nome?.toLowerCase().includes(searchLower)
      )
    }

    // 7. Get status counts for filter badges
    const { data: countData } = await supabase
      .from('documentos_paciente')
      .select('validado')

    const counts = {
      pendente: 0,
      aprovado: 0,
      rejeitado: 0,
      total: 0,
    }

    if (countData) {
      countData.forEach((doc: any) => {
        counts.total++
        if (doc.validado === null) counts.pendente++
        else if (doc.validado === true) counts.aprovado++
        else counts.rejeitado++
      })
    }

    // 8. Audit log
    await logAudit({
      userId: user.id,
      action: AuditAction.VIEW_DOCUMENTS,
      resource: 'documentos_paciente',
      details: { filters, resultCount: filteredData.length },
      ipAddress: req.headers.get('x-forwarded-for') || undefined,
      userAgent: req.headers.get('user-agent') || undefined,
    })

    // 9. Return response
    const total = count || 0
    return NextResponse.json({
      data: filteredData,
      pagination: {
        page: filters.page,
        limit: filters.limit,
        total,
        totalPages: Math.ceil(total / filters.limit),
      },
      counts,
    })
  } catch (error) {
    console.error('[patient-documents] Error:', error)
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Erro interno' },
      { status: 500 }
    )
  }
}
```
  </action>
  <verify>Test with curl: `curl -s http://localhost:3051/api/patient-documents | jq .pagination`</verify>
  <done>GET returns paginated documents with patient join, filters by status/type/date, includes status counts</done>
</task>

<task type="auto">
  <name>Task 2: Create approve, reject, and preview endpoints</name>
  <files>
    src/app/api/patient-documents/[id]/approve/route.ts
    src/app/api/patient-documents/[id]/reject/route.ts
    src/app/api/patient-documents/[id]/preview/route.ts
  </files>
  <action>
Create three endpoint files:

**approve/route.ts:**
```typescript
import { NextRequest, NextResponse } from 'next/server'
import { getCurrentUserWithRole } from '@/lib/auth/session'
import { logAudit, AuditAction } from '@/lib/audit/logger'
import { createServerSupabaseClient } from '@/lib/supabase/server'
import { approveDocumentSchema } from '@/lib/validations/patient-document'

export async function POST(
  req: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const user = await getCurrentUserWithRole()
    if (!user) {
      return NextResponse.json({ error: 'Nao autenticado' }, { status: 401 })
    }
    if (!['ADMIN', 'ATENDENTE'].includes(user.role)) {
      return NextResponse.json({ error: 'Sem permissao' }, { status: 403 })
    }

    const { id } = await params
    const body = await req.json()
    const validated = approveDocumentSchema.parse(body)

    const supabase = await createServerSupabaseClient()

    // Update document
    const { data, error } = await supabase
      .from('documentos_paciente')
      .update({
        validado: true,
        validado_por: user.id,
        observacoes: validated.observacoes || null,
      })
      .eq('id', id)
      .select()
      .single()

    if (error) {
      if (error.code === 'PGRST116') {
        return NextResponse.json({ error: 'Documento nao encontrado' }, { status: 404 })
      }
      throw new Error(error.message)
    }

    await logAudit({
      userId: user.id,
      action: AuditAction.APPROVE_DOCUMENT,
      resource: 'documentos_paciente',
      resourceId: id,
      details: { observacoes: validated.observacoes },
      ipAddress: req.headers.get('x-forwarded-for') || undefined,
      userAgent: req.headers.get('user-agent') || undefined,
    })

    return NextResponse.json(data)
  } catch (error) {
    console.error('[approve-document] Error:', error)
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Erro interno' },
      { status: 500 }
    )
  }
}
```

**reject/route.ts:**
Same structure but:
- Use rejectDocumentSchema (observacoes required)
- Set validado: false
- Use AuditAction.REJECT_DOCUMENT

**preview/route.ts:**
```typescript
import { NextRequest, NextResponse } from 'next/server'
import { getCurrentUserWithRole } from '@/lib/auth/session'
import { logAudit, AuditAction } from '@/lib/audit/logger'
import { createServerSupabaseClient } from '@/lib/supabase/server'

export async function GET(
  req: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const user = await getCurrentUserWithRole()
    if (!user) {
      return NextResponse.json({ error: 'Nao autenticado' }, { status: 401 })
    }
    if (!['ADMIN', 'ATENDENTE'].includes(user.role)) {
      return NextResponse.json({ error: 'Sem permissao' }, { status: 403 })
    }

    const { id } = await params
    const supabase = await createServerSupabaseClient()

    // Get document metadata
    const { data: doc, error: docError } = await supabase
      .from('documentos_paciente')
      .select('arquivo_path, tipo')
      .eq('id', id)
      .single()

    if (docError || !doc) {
      return NextResponse.json({ error: 'Documento nao encontrado' }, { status: 404 })
    }

    // Generate signed URL (1 hour expiry)
    const { data, error } = await supabase.storage
      .from('patient-documents')
      .createSignedUrl(doc.arquivo_path, 3600)

    if (error || !data) {
      console.error('[preview] Signed URL error:', error)
      return NextResponse.json({ error: 'Erro ao gerar URL' }, { status: 500 })
    }

    await logAudit({
      userId: user.id,
      action: AuditAction.VIEW_DOCUMENT,
      resource: 'documentos_paciente',
      resourceId: id,
      ipAddress: req.headers.get('x-forwarded-for') || undefined,
      userAgent: req.headers.get('user-agent') || undefined,
    })

    return NextResponse.json({
      url: data.signedUrl,
      tipo: doc.tipo,
    })
  } catch (error) {
    console.error('[preview] Error:', error)
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Erro interno' },
      { status: 500 }
    )
  }
}
```
  </action>
  <verify>Files created and TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>Approve sets validado=true, reject sets validado=false with reason, preview returns signed URL</done>
</task>

<task type="auto">
  <name>Task 3: Create bulk actions endpoint</name>
  <files>src/app/api/patient-documents/bulk/route.ts</files>
  <action>
Create bulk endpoint for approving/rejecting multiple documents:

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { getCurrentUserWithRole } from '@/lib/auth/session'
import { logAudit, AuditAction } from '@/lib/audit/logger'
import { createServerSupabaseClient } from '@/lib/supabase/server'
import { bulkDocumentActionSchema } from '@/lib/validations/patient-document'
import { z } from 'zod'

const bulkRequestSchema = z.object({
  action: z.enum(['approve', 'reject']),
  documentIds: z.array(z.string().uuid()).min(1),
  observacoes: z.string().optional(),
})

export async function POST(req: NextRequest) {
  try {
    const user = await getCurrentUserWithRole()
    if (!user) {
      return NextResponse.json({ error: 'Nao autenticado' }, { status: 401 })
    }
    if (!['ADMIN', 'ATENDENTE'].includes(user.role)) {
      return NextResponse.json({ error: 'Sem permissao' }, { status: 403 })
    }

    const body = await req.json()
    const validated = bulkRequestSchema.parse(body)

    // Reject requires reason
    if (validated.action === 'reject' && !validated.observacoes) {
      return NextResponse.json(
        { error: 'Motivo da rejeicao e obrigatorio' },
        { status: 400 }
      )
    }

    const supabase = await createServerSupabaseClient()

    // Update all documents
    const { data, error } = await supabase
      .from('documentos_paciente')
      .update({
        validado: validated.action === 'approve',
        validado_por: user.id,
        observacoes: validated.observacoes || null,
      })
      .in('id', validated.documentIds)
      .select()

    if (error) {
      throw new Error(error.message)
    }

    // Audit log
    await logAudit({
      userId: user.id,
      action: validated.action === 'approve'
        ? AuditAction.BULK_APPROVE_DOCUMENTS
        : AuditAction.BULK_REJECT_DOCUMENTS,
      resource: 'documentos_paciente',
      details: {
        documentIds: validated.documentIds,
        count: validated.documentIds.length,
        observacoes: validated.observacoes,
      },
      ipAddress: req.headers.get('x-forwarded-for') || undefined,
      userAgent: req.headers.get('user-agent') || undefined,
    })

    return NextResponse.json({
      success: true,
      count: data?.length || 0,
    })
  } catch (error) {
    console.error('[bulk-documents] Error:', error)
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Erro interno' },
      { status: 500 }
    )
  }
}
```
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>Bulk endpoint handles approve/reject for multiple document IDs with single reason</done>
</task>

</tasks>

<verification>
1. All API routes compile: `npx tsc --noEmit`
2. Dev server starts without errors: `npm run dev`
3. GET /api/patient-documents returns expected structure
</verification>

<success_criteria>
- GET /api/patient-documents returns paginated list with status counts
- POST /api/patient-documents/[id]/approve updates document and logs audit
- POST /api/patient-documents/[id]/reject requires reason and logs audit
- GET /api/patient-documents/[id]/preview returns signed URL
- POST /api/patient-documents/bulk handles multiple documents
</success_criteria>

<output>
After completion, create `.planning/phases/16-document-management/16-02-SUMMARY.md`
</output>
