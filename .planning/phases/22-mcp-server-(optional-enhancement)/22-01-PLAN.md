---
phase: 22-mcp-server
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/mcp/config.ts
  - src/mcp/logger.ts
  - src/mcp/heartbeat.ts
  - src/mcp/http-client.ts
  - src/mcp/server.ts
autonomous: true

must_haves:
  truths:
    - "MCP Server starts and connects via stdio transport without crashing"
    - "All logging goes to stderr (never stdout)"
    - "HTTP client attaches Bearer token to all requests"
    - "Heartbeat logs stats every 60 seconds to stderr"
  artifacts:
    - path: "src/mcp/config.ts"
      provides: "Configuration with AGENT_API_BASE_URL and AGENT_API_KEY from env"
      min_lines: 15
    - path: "src/mcp/logger.ts"
      provides: "stderr-only logging utilities"
      min_lines: 15
    - path: "src/mcp/heartbeat.ts"
      provides: "Heartbeat monitoring with request/error counters"
      min_lines: 30
    - path: "src/mcp/http-client.ts"
      provides: "HTTP client wrapper with Bearer auth and error handling"
      min_lines: 50
    - path: "src/mcp/server.ts"
      provides: "Main MCP server entry point"
      min_lines: 30
  key_links:
    - from: "src/mcp/server.ts"
      to: "http-client.ts"
      via: "imports for tool handlers"
      pattern: "import.*http-client"
    - from: "src/mcp/http-client.ts"
      to: "config.ts"
      via: "config.baseUrl and config.apiKey"
      pattern: "config\\.baseUrl|config\\.apiKey"
---

<objective>
Set up MCP Server foundation with configuration, HTTP client, logging, and heartbeat utilities.

Purpose: Create the infrastructure that all 11 tool handlers will use, ensuring proper authentication, error handling, and monitoring for Claude Desktop integration.

Output:
- `src/mcp/config.ts` - Environment-based configuration
- `src/mcp/logger.ts` - stderr-only logging (MCP requirement)
- `src/mcp/heartbeat.ts` - Monitoring with request counters
- `src/mcp/http-client.ts` - Authenticated HTTP client wrapper
- `src/mcp/server.ts` - Main MCP server entry point (minimal, tools added in later plans)
</objective>

<execution_context>
@/Users/gilberto/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gilberto/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-mcp-server-(optional-enhancement)/22-RESEARCH.md

# Reference existing auth patterns
@src/lib/agent/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MCP configuration and logging utilities</name>
  <files>
    src/mcp/config.ts
    src/mcp/logger.ts
    src/mcp/heartbeat.ts
  </files>
  <action>
Create three utility files for MCP server infrastructure:

**1. src/mcp/config.ts:**
```typescript
// Load from environment variables
export const config = {
  baseUrl: process.env.AGENT_API_BASE_URL || 'http://localhost:3051',
  apiKey: process.env.AGENT_API_KEY || '',
}

// Validate config on startup
export function validateConfig(): void {
  if (!config.apiKey) {
    throw new Error('AGENT_API_KEY environment variable is required')
  }
}
```

**2. src/mcp/logger.ts:**
Create stderr-only logging utilities (CRITICAL: MCP protocol uses stdout for JSON-RPC, all logs MUST go to stderr):
- `mcpLog.info(msg)` - Info logs to stderr
- `mcpLog.error(msg)` - Error logs to stderr
- `mcpLog.debug(msg)` - Debug logs to stderr (prefix with timestamp)
- Never use `console.log()` - always `console.error()`

**3. src/mcp/heartbeat.ts:**
Create heartbeat monitoring:
- `recordRequest(success: boolean)` - Track request/error counts
- `startHeartbeat(intervalMs = 60000)` - Log stats every minute
- Track: uptime, requests, errors, error rate
- Log as JSON to stderr for parsing
  </action>
  <verify>
Files exist and TypeScript compiles:
```bash
ls src/mcp/config.ts src/mcp/logger.ts src/mcp/heartbeat.ts
npx tsc --noEmit src/mcp/*.ts 2>&1 | head -20
```
  </verify>
  <done>Three utility files created with proper stderr logging and configuration validation</done>
</task>

<task type="auto">
  <name>Task 2: Create HTTP client wrapper with authentication</name>
  <files>src/mcp/http-client.ts</files>
  <action>
Create authenticated HTTP client for calling existing Next.js agent APIs:

```typescript
// src/mcp/http-client.ts
import { config } from './config'
import { mcpLog } from './logger'
import { recordRequest } from './heartbeat'

export interface ApiResponse<T = unknown> {
  success: boolean
  data?: T
  error?: string
  details?: Record<string, unknown>
}

export async function callAgentApi<T = unknown>(
  method: 'GET' | 'POST' | 'PATCH' | 'DELETE',
  path: string,
  options?: {
    params?: Record<string, string | number | undefined>
    body?: unknown
    contentType?: string // For multipart support later
  }
): Promise<T> {
  // Build URL with query params
  const url = new URL(`${config.baseUrl}/api/agent${path}`)

  if (options?.params) {
    Object.entries(options.params).forEach(([key, value]) => {
      if (value !== undefined) {
        url.searchParams.set(key, String(value))
      }
    })
  }

  // Make request with Bearer auth
  const headers: Record<string, string> = {
    'Authorization': `Bearer ${config.apiKey}`,
  }

  // Only set Content-Type for JSON (not for multipart)
  if (options?.body && !options?.contentType) {
    headers['Content-Type'] = 'application/json'
  }

  try {
    mcpLog.debug(`HTTP ${method} ${url.pathname}${url.search}`)

    const response = await fetch(url.toString(), {
      method,
      headers,
      body: options?.body ? JSON.stringify(options.body) : undefined,
    })

    const json = await response.json() as ApiResponse<T>

    // Check BOTH HTTP status AND success field (per research pitfall #3)
    if (!response.ok || !json.success) {
      recordRequest(false)
      throw new Error(json.error || `HTTP ${response.status}: ${response.statusText}`)
    }

    recordRequest(true)
    return json.data as T
  } catch (error) {
    recordRequest(false)
    mcpLog.error(`HTTP error: ${error instanceof Error ? error.message : 'Unknown'}`)
    throw error
  }
}
```

Key requirements from research:
- Bearer token attached to ALL requests
- Check both `response.ok` AND `json.success` field
- Track success/failure for heartbeat
- Log to stderr only
  </action>
  <verify>
File compiles and exports are correct:
```bash
npx tsc --noEmit src/mcp/http-client.ts
grep -c "Bearer" src/mcp/http-client.ts  # Should find Bearer token usage
```
  </verify>
  <done>HTTP client wrapper created with Bearer authentication, dual success checking, and heartbeat integration</done>
</task>

<task type="auto">
  <name>Task 3: Create main MCP server entry point</name>
  <files>src/mcp/server.ts</files>
  <action>
Create the main MCP server using `@modelcontextprotocol/sdk`:

**First, install the SDK:**
```bash
npm install @modelcontextprotocol/sdk
```

**Then create src/mcp/server.ts:**
```typescript
#!/usr/bin/env node
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js'
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js'
import { validateConfig } from './config'
import { mcpLog } from './logger'
import { startHeartbeat } from './heartbeat'

// Tool imports will be added in subsequent plans
// import { registerQueryTools } from './tools/query'
// import { registerWriteTools } from './tools/write'
// import { registerDocumentTool } from './tools/document'

async function main(): Promise<void> {
  try {
    // 1. Validate configuration
    mcpLog.info('Validating configuration...')
    validateConfig()

    // 2. Create MCP server
    mcpLog.info('Creating MCP server...')
    const server = new McpServer({
      name: 'botfy-clinicops',
      version: '2.0.0',
    })

    // 3. Register tools (added in plans 22-02, 22-03, 22-04)
    mcpLog.info('Registering tools...')
    // registerQueryTools(server)
    // registerWriteTools(server)
    // registerDocumentTool(server)

    // 4. Start heartbeat monitoring
    startHeartbeat(60000) // Every 60 seconds

    // 5. Connect via stdio transport (required for Claude Desktop)
    mcpLog.info('Connecting to stdio transport...')
    const transport = new StdioServerTransport()
    await server.connect(transport)

    mcpLog.info('Botfy ClinicOps MCP Server ready')
  } catch (error) {
    mcpLog.error(`Fatal error: ${error instanceof Error ? error.message : 'Unknown'}`)
    process.exit(1)
  }
}

// Handle graceful shutdown
process.on('SIGINT', () => {
  mcpLog.info('Shutting down...')
  process.exit(0)
})

process.on('SIGTERM', () => {
  mcpLog.info('Shutting down...')
  process.exit(0)
})

main()
```

Note: Tool registrations are commented out and will be added in plans 22-02, 22-03, 22-04.
  </action>
  <verify>
Install MCP SDK and verify server compiles:
```bash
npm install @modelcontextprotocol/sdk
npx tsc --noEmit src/mcp/server.ts
ls -la src/mcp/
```
  </verify>
  <done>MCP server entry point created with McpServer, StdioServerTransport, and graceful shutdown handling</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. All MCP infrastructure files exist:
```bash
ls -la src/mcp/
```

2. TypeScript compiles without errors:
```bash
npx tsc --noEmit src/mcp/*.ts
```

3. MCP SDK is installed:
```bash
grep "@modelcontextprotocol/sdk" package.json
```

4. No stdout logging in any MCP file (only stderr):
```bash
grep -r "console.log" src/mcp/ || echo "Good: No console.log found"
```
</verification>

<success_criteria>
- MCP SDK installed in package.json
- Five infrastructure files created in src/mcp/
- All files compile with TypeScript
- No console.log usage (only console.error via mcpLog)
- HTTP client includes Bearer token authentication
- Config validates API key presence
- Heartbeat tracks request/error counts
</success_criteria>

<output>
After completion, create `.planning/phases/22-mcp-server-(optional-enhancement)/22-01-SUMMARY.md`
</output>
