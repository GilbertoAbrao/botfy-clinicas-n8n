---
phase: 22-mcp-server
plan: 02
type: execute
wave: 2
depends_on: ["22-01"]
files_modified:
  - src/mcp/tools/buscar-slots.ts
  - src/mcp/tools/buscar-agendamentos.ts
  - src/mcp/tools/buscar-paciente.ts
  - src/mcp/tools/status-precheckin.ts
  - src/mcp/tools/buscar-instrucoes.ts
  - src/mcp/tools/query.ts
autonomous: true

must_haves:
  truths:
    - "Each query tool has correct MCP schema matching the Next.js API"
    - "Query tools return structured content for Claude consumption"
    - "Tool handlers catch errors and return MCP-compliant error format"
  artifacts:
    - path: "src/mcp/tools/buscar-slots.ts"
      provides: "Tool handler for GET /api/agent/slots"
      exports: ["buscarSlotsDisponiveisTool"]
    - path: "src/mcp/tools/buscar-agendamentos.ts"
      provides: "Tool handler for GET /api/agent/agendamentos"
      exports: ["buscarAgendamentosTool"]
    - path: "src/mcp/tools/buscar-paciente.ts"
      provides: "Tool handler for GET /api/agent/paciente"
      exports: ["buscarPacienteTool"]
    - path: "src/mcp/tools/status-precheckin.ts"
      provides: "Tool handler for GET /api/agent/pre-checkin/status"
      exports: ["statusPreCheckinTool"]
    - path: "src/mcp/tools/buscar-instrucoes.ts"
      provides: "Tool handler for GET /api/agent/instrucoes"
      exports: ["buscarInstrucoesTool"]
    - path: "src/mcp/tools/query.ts"
      provides: "Index file registering all 5 query tools with McpServer"
      exports: ["registerQueryTools"]
  key_links:
    - from: "src/mcp/tools/*.ts"
      to: "src/mcp/http-client.ts"
      via: "callAgentApi import"
      pattern: "import.*callAgentApi.*http-client"
---

<objective>
Create MCP tool handlers for all 5 read-only (query) agent APIs.

Purpose: Enable Claude Desktop to query available slots, appointments, patient data, pre-checkin status, and procedure instructions through the MCP protocol.

Output:
- 5 individual tool handler files in `src/mcp/tools/`
- 1 index file (`query.ts`) that registers all query tools with the MCP server
</objective>

<execution_context>
@/Users/gilberto/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gilberto/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-mcp-server-(optional-enhancement)/22-RESEARCH.md

# Reference existing API schemas and routes
@src/lib/validations/agent-schemas.ts
@src/app/api/agent/slots/route.ts
@src/app/api/agent/agendamentos/route.ts
@src/app/api/agent/paciente/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create slot and appointment query tools</name>
  <files>
    src/mcp/tools/buscar-slots.ts
    src/mcp/tools/buscar-agendamentos.ts
  </files>
  <action>
Create tool handlers for slots and appointments queries:

**1. src/mcp/tools/buscar-slots.ts:**
```typescript
import { z } from 'zod'
import { callAgentApi } from '../http-client'

// Input schema matching agentSlotsSearchSchema
const inputSchema = z.object({
  data: z.string().describe('Data no formato YYYY-MM-DD'),
  profissional: z.string().optional().describe('Nome do profissional'),
  servicoId: z.number().optional().describe('ID do serviço'),
  duracaoMinutos: z.number().optional().describe('Duração em minutos (default: 30)'),
})

// Output type from slot-service.ts
interface SlotsResult {
  date: string
  slots: string[]
  totalAvailable: number
  period?: {
    morning: string[]
    afternoon: string[]
  }
}

export const buscarSlotsDisponiveisTool = {
  name: 'buscar_slots_disponiveis',
  title: 'Buscar Slots Disponíveis',
  description: 'Busca horários disponíveis para agendamento em uma data específica. Retorna lista de horários vagos divididos por período (manhã/tarde).',
  inputSchema,
  handler: async (input: z.infer<typeof inputSchema>) => {
    try {
      const result = await callAgentApi<SlotsResult>('GET', '/slots', {
        params: {
          data: input.data,
          profissional: input.profissional,
          servicoId: input.servicoId,
          duracaoMinutos: input.duracaoMinutos,
        },
      })

      const summary = `Encontrados ${result.totalAvailable} horários disponíveis para ${result.date}`

      return {
        content: [{ type: 'text', text: summary }],
        structuredContent: result,
      }
    } catch (error) {
      return {
        content: [{
          type: 'text',
          text: `Erro ao buscar slots: ${error instanceof Error ? error.message : 'Erro desconhecido'}`,
        }],
        isError: true,
      }
    }
  },
}
```

**2. src/mcp/tools/buscar-agendamentos.ts:**
```typescript
import { z } from 'zod'
import { callAgentApi } from '../http-client'

// Input schema matching agentAppointmentSearchSchema
const inputSchema = z.object({
  pacienteId: z.number().optional().describe('ID do paciente'),
  telefone: z.string().optional().describe('Telefone do paciente (10-11 dígitos)'),
  dataInicio: z.string().optional().describe('Data inicial (ISO 8601)'),
  dataFim: z.string().optional().describe('Data final (ISO 8601)'),
  status: z.enum(['agendada', 'confirmada', 'presente', 'cancelada', 'faltou']).optional().describe('Status do agendamento'),
  servicoId: z.number().optional().describe('ID do serviço'),
  tipoConsulta: z.string().optional().describe('Tipo de consulta'),
  profissional: z.string().optional().describe('Nome do profissional'),
  page: z.number().optional().describe('Página (default: 1)'),
  limit: z.number().optional().describe('Itens por página (default: 20, max: 100)'),
})

interface Appointment {
  id: number
  dataHora: string
  tipoConsulta: string
  profissional: string | null
  status: string | null
  observacoes: string | null
  paciente: { id: number; nome: string; telefone: string }
}

interface AppointmentsResult {
  agendamentos: Appointment[]
  pagination: {
    page: number
    limit: number
    total: number
    totalPages: number
  }
}

export const buscarAgendamentosTool = {
  name: 'buscar_agendamentos',
  title: 'Buscar Agendamentos',
  description: 'Busca agendamentos com filtros por paciente, data, status, serviço ou profissional. Suporta paginação.',
  inputSchema,
  handler: async (input: z.infer<typeof inputSchema>) => {
    try {
      const result = await callAgentApi<AppointmentsResult>('GET', '/agendamentos', {
        params: {
          pacienteId: input.pacienteId,
          telefone: input.telefone,
          dataInicio: input.dataInicio,
          dataFim: input.dataFim,
          status: input.status,
          servicoId: input.servicoId,
          tipoConsulta: input.tipoConsulta,
          profissional: input.profissional,
          page: input.page,
          limit: input.limit,
        },
      })

      const summary = `Encontrados ${result.pagination.total} agendamentos (página ${result.pagination.page}/${result.pagination.totalPages})`

      return {
        content: [{ type: 'text', text: summary }],
        structuredContent: result,
      }
    } catch (error) {
      return {
        content: [{
          type: 'text',
          text: `Erro ao buscar agendamentos: ${error instanceof Error ? error.message : 'Erro desconhecido'}`,
        }],
        isError: true,
      }
    }
  },
}
```
  </action>
  <verify>
Files exist and TypeScript compiles:
```bash
ls src/mcp/tools/buscar-slots.ts src/mcp/tools/buscar-agendamentos.ts
npx tsc --noEmit src/mcp/tools/buscar-slots.ts src/mcp/tools/buscar-agendamentos.ts
```
  </verify>
  <done>Slot search and appointment search tool handlers created with proper schemas and error handling</done>
</task>

<task type="auto">
  <name>Task 2: Create patient, pre-checkin, and instructions query tools</name>
  <files>
    src/mcp/tools/buscar-paciente.ts
    src/mcp/tools/status-precheckin.ts
    src/mcp/tools/buscar-instrucoes.ts
  </files>
  <action>
Create tool handlers for remaining query tools:

**1. src/mcp/tools/buscar-paciente.ts:**
```typescript
import { z } from 'zod'
import { callAgentApi } from '../http-client'

// Input schema - at least one search parameter required
const inputSchema = z.object({
  telefone: z.string().optional().describe('Telefone do paciente (10-11 dígitos)'),
  cpf: z.string().optional().describe('CPF do paciente (11 dígitos)'),
  nome: z.string().optional().describe('Nome do paciente (busca parcial)'),
})

interface Patient {
  id: number
  nome: string
  telefone: string
  email: string | null
  cpf: string | null
  dataNascimento: string | null
  convenio: string | null
  observacoes: string | null
}

interface PatientResult {
  paciente: Patient | null
  proximosAgendamentos?: Array<{
    id: number
    dataHora: string
    tipoConsulta: string
    status: string | null
  }>
  matchType: 'exact' | 'partial' | 'none'
  partialMatches?: Array<{ id: number; nome: string; telefone: string }>
}

export const buscarPacienteTool = {
  name: 'buscar_paciente',
  title: 'Buscar Paciente',
  description: 'Busca paciente por telefone, CPF ou nome. Retorna dados do paciente e próximos agendamentos quando encontrado.',
  inputSchema,
  handler: async (input: z.infer<typeof inputSchema>) => {
    try {
      // Validate at least one parameter
      if (!input.telefone && !input.cpf && !input.nome) {
        return {
          content: [{
            type: 'text',
            text: 'Erro: Pelo menos um parâmetro de busca é necessário (telefone, cpf ou nome)',
          }],
          isError: true,
        }
      }

      const result = await callAgentApi<PatientResult>('GET', '/paciente', {
        params: {
          telefone: input.telefone,
          cpf: input.cpf,
          nome: input.nome,
        },
      })

      let summary: string
      if (result.matchType === 'exact' && result.paciente) {
        summary = `Paciente encontrado: ${result.paciente.nome} (ID: ${result.paciente.id})`
        if (result.proximosAgendamentos?.length) {
          summary += `. ${result.proximosAgendamentos.length} próximos agendamentos.`
        }
      } else if (result.matchType === 'partial' && result.partialMatches) {
        summary = `${result.partialMatches.length} pacientes encontrados com busca parcial`
      } else {
        summary = 'Nenhum paciente encontrado'
      }

      return {
        content: [{ type: 'text', text: summary }],
        structuredContent: result,
      }
    } catch (error) {
      return {
        content: [{
          type: 'text',
          text: `Erro ao buscar paciente: ${error instanceof Error ? error.message : 'Erro desconhecido'}`,
        }],
        isError: true,
      }
    }
  },
}
```

**2. src/mcp/tools/status-precheckin.ts:**
```typescript
import { z } from 'zod'
import { callAgentApi } from '../http-client'

// Input schema - at least one parameter required
const inputSchema = z.object({
  agendamentoId: z.number().optional().describe('ID do agendamento'),
  pacienteId: z.number().optional().describe('ID do paciente'),
  telefone: z.string().optional().describe('Telefone do paciente'),
})

interface PreCheckinStatus {
  agendamentoId: number
  pacienteId: number
  status: string
  documentos: Array<{
    tipo: string
    status: 'pendente' | 'enviado' | 'aprovado' | 'rejeitado'
    enviadoEm?: string
  }>
  completude: number // 0-100
}

export const statusPreCheckinTool = {
  name: 'status_pre_checkin',
  title: 'Status Pré Check-in',
  description: 'Consulta o status do pré check-in de um agendamento, incluindo documentos enviados e pendentes.',
  inputSchema,
  handler: async (input: z.infer<typeof inputSchema>) => {
    try {
      // Validate at least one parameter
      if (!input.agendamentoId && !input.pacienteId && !input.telefone) {
        return {
          content: [{
            type: 'text',
            text: 'Erro: Pelo menos um parâmetro é necessário (agendamentoId, pacienteId ou telefone)',
          }],
          isError: true,
        }
      }

      const result = await callAgentApi<PreCheckinStatus>('GET', '/pre-checkin/status', {
        params: {
          agendamentoId: input.agendamentoId,
          pacienteId: input.pacienteId,
          telefone: input.telefone,
        },
      })

      const summary = `Pré check-in ${result.completude}% completo. Status: ${result.status}`

      return {
        content: [{ type: 'text', text: summary }],
        structuredContent: result,
      }
    } catch (error) {
      return {
        content: [{
          type: 'text',
          text: `Erro ao consultar pré check-in: ${error instanceof Error ? error.message : 'Erro desconhecido'}`,
        }],
        isError: true,
      }
    }
  },
}
```

**3. src/mcp/tools/buscar-instrucoes.ts:**
```typescript
import { z } from 'zod'
import { callAgentApi } from '../http-client'

const inputSchema = z.object({
  servicoId: z.number().optional().describe('ID do serviço'),
  tipoInstrucao: z.string().optional().describe('Tipo de instrução (jejum, hidratacao, medicacao, etc)'),
})

interface Instrucao {
  id: number
  servicoId: number
  tipoInstrucao: string
  titulo: string
  conteudo: string
  prioridade: number
}

interface InstrucoesResult {
  instrucoes: Instrucao[]
  total: number
}

export const buscarInstrucoesTool = {
  name: 'buscar_instrucoes',
  title: 'Buscar Instruções',
  description: 'Busca instruções de procedimentos por serviço ou tipo. Retorna instruções formatadas para envio via WhatsApp.',
  inputSchema,
  handler: async (input: z.infer<typeof inputSchema>) => {
    try {
      const result = await callAgentApi<InstrucoesResult>('GET', '/instrucoes', {
        params: {
          servicoId: input.servicoId,
          tipoInstrucao: input.tipoInstrucao,
        },
      })

      const summary = `Encontradas ${result.total} instruções`

      return {
        content: [{ type: 'text', text: summary }],
        structuredContent: result,
      }
    } catch (error) {
      return {
        content: [{
          type: 'text',
          text: `Erro ao buscar instruções: ${error instanceof Error ? error.message : 'Erro desconhecido'}`,
        }],
        isError: true,
      }
    }
  },
}
```
  </action>
  <verify>
Files exist and compile:
```bash
ls src/mcp/tools/buscar-paciente.ts src/mcp/tools/status-precheckin.ts src/mcp/tools/buscar-instrucoes.ts
npx tsc --noEmit src/mcp/tools/buscar-paciente.ts src/mcp/tools/status-precheckin.ts src/mcp/tools/buscar-instrucoes.ts
```
  </verify>
  <done>Patient, pre-checkin status, and instructions tool handlers created</done>
</task>

<task type="auto">
  <name>Task 3: Create query tools index with McpServer registration</name>
  <files>src/mcp/tools/query.ts</files>
  <action>
Create an index file that registers all 5 query tools with the MCP server:

```typescript
// src/mcp/tools/query.ts
import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js'
import { buscarSlotsDisponiveisTool } from './buscar-slots'
import { buscarAgendamentosTool } from './buscar-agendamentos'
import { buscarPacienteTool } from './buscar-paciente'
import { statusPreCheckinTool } from './status-precheckin'
import { buscarInstrucoesTool } from './buscar-instrucoes'
import { mcpLog } from '../logger'

// Helper to convert Zod schema to JSON Schema for MCP
function zodToJsonSchema(schema: Record<string, unknown>): Record<string, unknown> {
  // MCP SDK accepts Zod schemas directly via zodToJsonSchema internally
  // We return the shape for the SDK to process
  return {
    type: 'object',
    properties: schema,
  }
}

export function registerQueryTools(server: McpServer): void {
  mcpLog.info('Registering query tools...')

  // 1. buscar_slots_disponiveis
  server.tool(
    buscarSlotsDisponiveisTool.name,
    buscarSlotsDisponiveisTool.description,
    buscarSlotsDisponiveisTool.inputSchema,
    buscarSlotsDisponiveisTool.handler
  )
  mcpLog.info(`  ✓ ${buscarSlotsDisponiveisTool.name}`)

  // 2. buscar_agendamentos
  server.tool(
    buscarAgendamentosTool.name,
    buscarAgendamentosTool.description,
    buscarAgendamentosTool.inputSchema,
    buscarAgendamentosTool.handler
  )
  mcpLog.info(`  ✓ ${buscarAgendamentosTool.name}`)

  // 3. buscar_paciente
  server.tool(
    buscarPacienteTool.name,
    buscarPacienteTool.description,
    buscarPacienteTool.inputSchema,
    buscarPacienteTool.handler
  )
  mcpLog.info(`  ✓ ${buscarPacienteTool.name}`)

  // 4. status_pre_checkin
  server.tool(
    statusPreCheckinTool.name,
    statusPreCheckinTool.description,
    statusPreCheckinTool.inputSchema,
    statusPreCheckinTool.handler
  )
  mcpLog.info(`  ✓ ${statusPreCheckinTool.name}`)

  // 5. buscar_instrucoes
  server.tool(
    buscarInstrucoesTool.name,
    buscarInstrucoesTool.description,
    buscarInstrucoesTool.inputSchema,
    buscarInstrucoesTool.handler
  )
  mcpLog.info(`  ✓ ${buscarInstrucoesTool.name}`)

  mcpLog.info('Query tools registered: 5')
}
```

Note: The MCP SDK's `server.tool()` method accepts Zod schemas directly and handles conversion internally.
  </action>
  <verify>
File exists and exports registerQueryTools:
```bash
ls src/mcp/tools/query.ts
grep "export function registerQueryTools" src/mcp/tools/query.ts
npx tsc --noEmit src/mcp/tools/query.ts
```
  </verify>
  <done>Query tools index created with registerQueryTools function for MCP server registration</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. All 6 files exist in src/mcp/tools/:
```bash
ls -la src/mcp/tools/
```

2. All files compile:
```bash
npx tsc --noEmit src/mcp/tools/*.ts
```

3. Each tool has correct name matching N8N tool names:
```bash
grep -h "name:" src/mcp/tools/buscar-*.ts src/mcp/tools/status-*.ts | grep -v "^//"
```

4. All tools use callAgentApi from http-client:
```bash
grep -l "callAgentApi" src/mcp/tools/*.ts | wc -l  # Should be 5
```
</verification>

<success_criteria>
- 5 tool handler files created (buscar-slots, buscar-agendamentos, buscar-paciente, status-precheckin, buscar-instrucoes)
- 1 index file (query.ts) with registerQueryTools function
- All tools use callAgentApi with correct HTTP methods (GET)
- All tools have error handling returning MCP-compliant format
- All tools provide summary text and structuredContent
- Tool names match existing N8N tool names exactly
</success_criteria>

<output>
After completion, create `.planning/phases/22-mcp-server-(optional-enhancement)/22-02-SUMMARY.md`
</output>
