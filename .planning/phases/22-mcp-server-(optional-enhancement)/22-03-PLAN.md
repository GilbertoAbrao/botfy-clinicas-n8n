---
phase: 22-mcp-server
plan: 03
type: execute
wave: 2
depends_on: ["22-01"]
files_modified:
  - src/mcp/tools/criar-agendamento.ts
  - src/mcp/tools/reagendar.ts
  - src/mcp/tools/cancelar.ts
  - src/mcp/tools/atualizar-paciente.ts
  - src/mcp/tools/confirmar-presenca.ts
  - src/mcp/tools/write.ts
autonomous: true

must_haves:
  truths:
    - "Each write tool has correct MCP schema matching the Next.js API"
    - "Write tools use correct HTTP methods (POST, PATCH, DELETE)"
    - "Tool handlers catch errors and return MCP-compliant error format"
    - "Idempotency key support in criar_agendamento tool"
  artifacts:
    - path: "src/mcp/tools/criar-agendamento.ts"
      provides: "Tool handler for POST /api/agent/agendamentos"
      exports: ["criarAgendamentoTool"]
    - path: "src/mcp/tools/reagendar.ts"
      provides: "Tool handler for PATCH /api/agent/agendamentos/:id"
      exports: ["reagendarAgendamentoTool"]
    - path: "src/mcp/tools/cancelar.ts"
      provides: "Tool handler for DELETE /api/agent/agendamentos/:id"
      exports: ["cancelarAgendamentoTool"]
    - path: "src/mcp/tools/atualizar-paciente.ts"
      provides: "Tool handler for PATCH /api/agent/paciente/:id"
      exports: ["atualizarDadosPacienteTool"]
    - path: "src/mcp/tools/confirmar-presenca.ts"
      provides: "Tool handler for POST /api/agent/agendamentos/:id/confirmar"
      exports: ["confirmarPresencaTool"]
    - path: "src/mcp/tools/write.ts"
      provides: "Index file registering all 5 write tools with McpServer"
      exports: ["registerWriteTools"]
  key_links:
    - from: "src/mcp/tools/write.ts"
      to: "src/mcp/tools/*.ts"
      via: "imports for tool registration"
      pattern: "import.*Tool.*from"
---

<objective>
Create MCP tool handlers for all 5 write (create/update/delete) agent APIs.

Purpose: Enable Claude Desktop to create appointments, reschedule, cancel, update patient data, and confirm attendance through the MCP protocol.

Output:
- 5 individual tool handler files in `src/mcp/tools/`
- 1 index file (`write.ts`) that registers all write tools with the MCP server
</objective>

<execution_context>
@/Users/gilberto/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gilberto/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-mcp-server-(optional-enhancement)/22-RESEARCH.md

# Reference existing API schemas
@src/lib/validations/agent-schemas.ts
@src/app/api/agent/agendamentos/route.ts
@src/app/api/agent/agendamentos/[id]/route.ts
@src/app/api/agent/agendamentos/[id]/confirmar/route.ts
@src/app/api/agent/paciente/[id]/route.ts

# Reference http-client from 22-01
# @src/mcp/http-client.ts (created in 22-01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create appointment write tools (create, reschedule, cancel)</name>
  <files>
    src/mcp/tools/criar-agendamento.ts
    src/mcp/tools/reagendar.ts
    src/mcp/tools/cancelar.ts
  </files>
  <action>
Create tool handlers for appointment creation, rescheduling, and cancellation:

**1. src/mcp/tools/criar-agendamento.ts:**
```typescript
import { z } from 'zod'
import { callAgentApi } from '../http-client'

// Input schema matching agentCreateAppointmentSchema
const inputSchema = z.object({
  pacienteId: z.number().describe('ID do paciente'),
  dataHora: z.string().describe('Data e hora (ISO 8601, ex: 2026-01-25T14:30:00-03:00)'),
  tipoConsulta: z.string().optional().describe('Tipo de consulta (obrigatório se não informar servicoId)'),
  servicoId: z.number().optional().describe('ID do serviço'),
  profissional: z.string().optional().describe('Nome do profissional'),
  observacoes: z.string().optional().describe('Observações (max 500 caracteres)'),
  idempotencyKey: z.string().optional().describe('Chave de idempotência (UUID) para evitar duplicatas'),
})

interface CreatedAppointment {
  id: number
  dataHora: string
  tipoConsulta: string
  profissional: string | null
  status: string
  paciente: { id: number; nome: string; telefone: string }
}

export const criarAgendamentoTool = {
  name: 'criar_agendamento',
  title: 'Criar Agendamento',
  description: 'Cria um novo agendamento para o paciente. Verifica conflitos de horário e suporta idempotência para retry seguro.',
  inputSchema,
  handler: async (input: z.infer<typeof inputSchema>) => {
    try {
      // Validate business rule: servicoId OR tipoConsulta required
      if (!input.servicoId && !input.tipoConsulta) {
        return {
          content: [{
            type: 'text',
            text: 'Erro: É necessário informar servicoId ou tipoConsulta',
          }],
          isError: true,
        }
      }

      const result = await callAgentApi<CreatedAppointment>('POST', '/agendamentos', {
        body: input,
      })

      const summary = `Agendamento criado com sucesso. ID: ${result.id}, Data: ${result.dataHora}, Paciente: ${result.paciente.nome}`

      return {
        content: [{ type: 'text', text: summary }],
        structuredContent: result,
      }
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : 'Erro desconhecido'

      // Handle specific error cases
      if (errorMsg.includes('Horario ja ocupado') || errorMsg.includes('conflict')) {
        return {
          content: [{
            type: 'text',
            text: `Conflito de horário: O horário solicitado já está ocupado. Tente outro horário.`,
          }],
          isError: true,
        }
      }

      return {
        content: [{
          type: 'text',
          text: `Erro ao criar agendamento: ${errorMsg}`,
        }],
        isError: true,
      }
    }
  },
}
```

**2. src/mcp/tools/reagendar.ts:**
```typescript
import { z } from 'zod'
import { callAgentApi } from '../http-client'

// Input schema matching agentUpdateAppointmentSchema
const inputSchema = z.object({
  agendamentoId: z.number().describe('ID do agendamento a ser reagendado'),
  dataHora: z.string().optional().describe('Nova data e hora (ISO 8601)'),
  profissional: z.string().optional().describe('Novo profissional'),
  observacoes: z.string().optional().describe('Novas observações'),
})

interface UpdatedAppointment {
  id: number
  dataHora: string
  tipoConsulta: string
  profissional: string | null
  status: string | null
  paciente: { id: number; nome: string; telefone: string }
}

export const reagendarAgendamentoTool = {
  name: 'reagendar_agendamento',
  title: 'Reagendar Agendamento',
  description: 'Reagenda um agendamento existente para nova data/hora ou profissional. Valida disponibilidade do novo horário.',
  inputSchema,
  handler: async (input: z.infer<typeof inputSchema>) => {
    try {
      // Build update body (exclude agendamentoId)
      const { agendamentoId, ...updateData } = input

      const result = await callAgentApi<UpdatedAppointment>('PATCH', `/agendamentos/${agendamentoId}`, {
        body: updateData,
      })

      const summary = `Agendamento ${result.id} reagendado. Nova data: ${result.dataHora}`

      return {
        content: [{ type: 'text', text: summary }],
        structuredContent: result,
      }
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : 'Erro desconhecido'

      if (errorMsg.includes('not found') || errorMsg.includes('404')) {
        return {
          content: [{
            type: 'text',
            text: `Agendamento não encontrado. Verifique o ID informado.`,
          }],
          isError: true,
        }
      }

      return {
        content: [{
          type: 'text',
          text: `Erro ao reagendar: ${errorMsg}`,
        }],
        isError: true,
      }
    }
  },
}
```

**3. src/mcp/tools/cancelar.ts:**
```typescript
import { z } from 'zod'
import { callAgentApi } from '../http-client'

// Input schema matching agentCancelAppointmentSchema
const inputSchema = z.object({
  agendamentoId: z.number().describe('ID do agendamento a ser cancelado'),
  motivo: z.string().describe('Motivo do cancelamento (min 3 caracteres)'),
})

interface CancelledAppointment {
  id: number
  status: string
  cancelledAt: string
}

export const cancelarAgendamentoTool = {
  name: 'cancelar_agendamento',
  title: 'Cancelar Agendamento',
  description: 'Cancela um agendamento existente. Requer motivo do cancelamento. Dispara notificação para lista de espera.',
  inputSchema,
  handler: async (input: z.infer<typeof inputSchema>) => {
    try {
      // Validate motivo length
      if (input.motivo.length < 3) {
        return {
          content: [{
            type: 'text',
            text: 'Erro: O motivo do cancelamento deve ter pelo menos 3 caracteres',
          }],
          isError: true,
        }
      }

      const result = await callAgentApi<CancelledAppointment>('DELETE', `/agendamentos/${input.agendamentoId}`, {
        body: { motivo: input.motivo },
      })

      const summary = `Agendamento ${result.id} cancelado com sucesso.`

      return {
        content: [{ type: 'text', text: summary }],
        structuredContent: result,
      }
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : 'Erro desconhecido'

      if (errorMsg.includes('not found') || errorMsg.includes('404')) {
        return {
          content: [{
            type: 'text',
            text: `Agendamento não encontrado. Verifique o ID informado.`,
          }],
          isError: true,
        }
      }

      return {
        content: [{
          type: 'text',
          text: `Erro ao cancelar: ${errorMsg}`,
        }],
        isError: true,
      }
    }
  },
}
```
  </action>
  <verify>
Files exist and compile:
```bash
ls src/mcp/tools/criar-agendamento.ts src/mcp/tools/reagendar.ts src/mcp/tools/cancelar.ts
npx tsc --noEmit src/mcp/tools/criar-agendamento.ts src/mcp/tools/reagendar.ts src/mcp/tools/cancelar.ts
```
  </verify>
  <done>Appointment create, reschedule, and cancel tool handlers created with correct HTTP methods and error handling</done>
</task>

<task type="auto">
  <name>Task 2: Create patient update and appointment confirmation tools</name>
  <files>
    src/mcp/tools/atualizar-paciente.ts
    src/mcp/tools/confirmar-presenca.ts
  </files>
  <action>
Create tool handlers for patient update and attendance confirmation:

**1. src/mcp/tools/atualizar-paciente.ts:**
```typescript
import { z } from 'zod'
import { callAgentApi } from '../http-client'

// Input schema matching agentUpdatePatientSchema
const inputSchema = z.object({
  pacienteId: z.number().describe('ID do paciente a ser atualizado'),
  nome: z.string().optional().describe('Novo nome do paciente'),
  telefone: z.string().optional().describe('Novo telefone (10-11 dígitos)'),
  email: z.string().optional().describe('Novo email'),
  cpf: z.string().optional().describe('Novo CPF (11 dígitos)'),
  dataNascimento: z.string().optional().describe('Nova data de nascimento (YYYY-MM-DD)'),
  convenio: z.string().optional().describe('Novo convênio'),
  observacoes: z.string().optional().describe('Novas observações'),
})

interface UpdatedPatient {
  id: number
  nome: string
  telefone: string
  email: string | null
  cpf: string | null
  dataNascimento: string | null
  convenio: string | null
}

export const atualizarDadosPacienteTool = {
  name: 'atualizar_dados_paciente',
  title: 'Atualizar Dados do Paciente',
  description: 'Atualiza dados cadastrais do paciente (nome, telefone, email, CPF, etc). Suporta atualização parcial.',
  inputSchema,
  handler: async (input: z.infer<typeof inputSchema>) => {
    try {
      // Build update body (exclude pacienteId)
      const { pacienteId, ...updateData } = input

      // Check if at least one field to update
      if (Object.keys(updateData).length === 0) {
        return {
          content: [{
            type: 'text',
            text: 'Erro: Pelo menos um campo deve ser informado para atualização',
          }],
          isError: true,
        }
      }

      const result = await callAgentApi<UpdatedPatient>('PATCH', `/paciente/${pacienteId}`, {
        body: updateData,
      })

      const updatedFields = Object.keys(updateData).join(', ')
      const summary = `Paciente ${result.id} (${result.nome}) atualizado. Campos: ${updatedFields}`

      return {
        content: [{ type: 'text', text: summary }],
        structuredContent: result,
      }
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : 'Erro desconhecido'

      if (errorMsg.includes('not found') || errorMsg.includes('404')) {
        return {
          content: [{
            type: 'text',
            text: `Paciente não encontrado. Verifique o ID informado.`,
          }],
          isError: true,
        }
      }

      if (errorMsg.includes('phone') || errorMsg.includes('telefone')) {
        return {
          content: [{
            type: 'text',
            text: `Erro: Telefone já cadastrado para outro paciente.`,
          }],
          isError: true,
        }
      }

      return {
        content: [{
          type: 'text',
          text: `Erro ao atualizar paciente: ${errorMsg}`,
        }],
        isError: true,
      }
    }
  },
}
```

**2. src/mcp/tools/confirmar-presenca.ts:**
```typescript
import { z } from 'zod'
import { callAgentApi } from '../http-client'

// Input schema matching agentConfirmAppointmentSchema
const inputSchema = z.object({
  agendamentoId: z.number().describe('ID do agendamento'),
  tipo: z.enum(['confirmado', 'presente']).optional().describe('Tipo de confirmação: "confirmado" (paciente confirmou) ou "presente" (paciente chegou). Default: confirmado'),
})

interface ConfirmedAppointment {
  id: number
  status: string
  confirmedAt: string
}

export const confirmarPresencaTool = {
  name: 'confirmar_presenca',
  title: 'Confirmar Presença',
  description: 'Confirma agendamento ou registra presença do paciente. Use "confirmado" quando paciente confirma por WhatsApp, "presente" quando paciente chega na clínica.',
  inputSchema,
  handler: async (input: z.infer<typeof inputSchema>) => {
    try {
      const result = await callAgentApi<ConfirmedAppointment>('POST', `/agendamentos/${input.agendamentoId}/confirmar`, {
        body: { tipo: input.tipo || 'confirmado' },
      })

      const tipoMsg = result.status === 'presente' ? 'Presença registrada' : 'Agendamento confirmado'
      const summary = `${tipoMsg} para agendamento ${result.id}. Status: ${result.status}`

      return {
        content: [{ type: 'text', text: summary }],
        structuredContent: result,
      }
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : 'Erro desconhecido'

      if (errorMsg.includes('not found') || errorMsg.includes('404')) {
        return {
          content: [{
            type: 'text',
            text: `Agendamento não encontrado. Verifique o ID informado.`,
          }],
          isError: true,
        }
      }

      if (errorMsg.includes('terminal') || errorMsg.includes('cancelled')) {
        return {
          content: [{
            type: 'text',
            text: `Não é possível confirmar: agendamento já está cancelado ou finalizado.`,
          }],
          isError: true,
        }
      }

      return {
        content: [{
          type: 'text',
          text: `Erro ao confirmar presença: ${errorMsg}`,
        }],
        isError: true,
      }
    }
  },
}
```
  </action>
  <verify>
Files exist and compile:
```bash
ls src/mcp/tools/atualizar-paciente.ts src/mcp/tools/confirmar-presenca.ts
npx tsc --noEmit src/mcp/tools/atualizar-paciente.ts src/mcp/tools/confirmar-presenca.ts
```
  </verify>
  <done>Patient update and appointment confirmation tool handlers created with partial update and state validation</done>
</task>

<task type="auto">
  <name>Task 3: Create write tools index with McpServer registration</name>
  <files>src/mcp/tools/write.ts</files>
  <action>
Create an index file that registers all 5 write tools with the MCP server:

```typescript
// src/mcp/tools/write.ts
import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js'
import { criarAgendamentoTool } from './criar-agendamento'
import { reagendarAgendamentoTool } from './reagendar'
import { cancelarAgendamentoTool } from './cancelar'
import { atualizarDadosPacienteTool } from './atualizar-paciente'
import { confirmarPresencaTool } from './confirmar-presenca'
import { mcpLog } from '../logger'

export function registerWriteTools(server: McpServer): void {
  mcpLog.info('Registering write tools...')

  // 1. criar_agendamento
  server.tool(
    criarAgendamentoTool.name,
    criarAgendamentoTool.description,
    criarAgendamentoTool.inputSchema,
    criarAgendamentoTool.handler
  )
  mcpLog.info(`  ✓ ${criarAgendamentoTool.name}`)

  // 2. reagendar_agendamento
  server.tool(
    reagendarAgendamentoTool.name,
    reagendarAgendamentoTool.description,
    reagendarAgendamentoTool.inputSchema,
    reagendarAgendamentoTool.handler
  )
  mcpLog.info(`  ✓ ${reagendarAgendamentoTool.name}`)

  // 3. cancelar_agendamento
  server.tool(
    cancelarAgendamentoTool.name,
    cancelarAgendamentoTool.description,
    cancelarAgendamentoTool.inputSchema,
    cancelarAgendamentoTool.handler
  )
  mcpLog.info(`  ✓ ${cancelarAgendamentoTool.name}`)

  // 4. atualizar_dados_paciente
  server.tool(
    atualizarDadosPacienteTool.name,
    atualizarDadosPacienteTool.description,
    atualizarDadosPacienteTool.inputSchema,
    atualizarDadosPacienteTool.handler
  )
  mcpLog.info(`  ✓ ${atualizarDadosPacienteTool.name}`)

  // 5. confirmar_presenca
  server.tool(
    confirmarPresencaTool.name,
    confirmarPresencaTool.description,
    confirmarPresencaTool.inputSchema,
    confirmarPresencaTool.handler
  )
  mcpLog.info(`  ✓ ${confirmarPresencaTool.name}`)

  mcpLog.info('Write tools registered: 5')
}
```
  </action>
  <verify>
File exists and exports registerWriteTools:
```bash
ls src/mcp/tools/write.ts
grep "export function registerWriteTools" src/mcp/tools/write.ts
npx tsc --noEmit src/mcp/tools/write.ts
```
  </verify>
  <done>Write tools index created with registerWriteTools function for MCP server registration</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. All 6 files exist in src/mcp/tools/:
```bash
ls -la src/mcp/tools/criar-agendamento.ts src/mcp/tools/reagendar.ts src/mcp/tools/cancelar.ts src/mcp/tools/atualizar-paciente.ts src/mcp/tools/confirmar-presenca.ts src/mcp/tools/write.ts
```

2. All files compile:
```bash
npx tsc --noEmit src/mcp/tools/criar-agendamento.ts src/mcp/tools/reagendar.ts src/mcp/tools/cancelar.ts src/mcp/tools/atualizar-paciente.ts src/mcp/tools/confirmar-presenca.ts src/mcp/tools/write.ts
```

3. Each tool uses correct HTTP method:
```bash
grep -h "callAgentApi" src/mcp/tools/criar-agendamento.ts src/mcp/tools/reagendar.ts src/mcp/tools/cancelar.ts src/mcp/tools/atualizar-paciente.ts src/mcp/tools/confirmar-presenca.ts
# Should show: POST for criar, PATCH for reagendar/atualizar, DELETE for cancelar, POST for confirmar
```

4. All tools handle errors with MCP format:
```bash
grep -l "isError: true" src/mcp/tools/*.ts | wc -l  # Should be 5 write tools
```
</verification>

<success_criteria>
- 5 tool handler files created for write operations
- 1 index file (write.ts) with registerWriteTools function
- Correct HTTP methods: POST (criar, confirmar), PATCH (reagendar, atualizar), DELETE (cancelar)
- All tools have error handling with MCP-compliant format
- All tools provide summary text and structuredContent
- Tool names match existing N8N tool names exactly
- Idempotency key supported in criar_agendamento
</success_criteria>

<output>
After completion, create `.planning/phases/22-mcp-server-(optional-enhancement)/22-03-SUMMARY.md`
</output>
