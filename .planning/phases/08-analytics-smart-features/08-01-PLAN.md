---
phase: 08-analytics-smart-features
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/analytics/priority-scorer.ts
  - src/lib/analytics/pattern-detector.ts
  - src/lib/analytics/kpi-calculator.ts
autonomous: true

must_haves:
  truths:
    - "Priority scorer calculates score 1-100 based on alert context"
    - "Pattern detector identifies recurring failure patterns"
    - "KPI calculator computes booking success, no-show rate, resolution time"
  artifacts:
    - path: "src/lib/analytics/priority-scorer.ts"
      provides: "Alert priority scoring algorithm"
      exports: ["calculateAlertPriority", "PriorityFactors"]
      min_lines: 50
    - path: "src/lib/analytics/pattern-detector.ts"
      provides: "Failure pattern detection"
      exports: ["detectPatterns", "Pattern", "PatternType"]
      min_lines: 80
    - path: "src/lib/analytics/kpi-calculator.ts"
      provides: "Extended KPI calculations"
      exports: ["calculateKPIs", "KPIMetrics"]
      min_lines: 60
  key_links:
    - from: "priority-scorer.ts"
      to: "prisma.alert + prisma.patient"
      via: "database queries for context"
      pattern: "prisma\\.(alert|patient)\\."
    - from: "pattern-detector.ts"
      to: "prisma.appointment + prisma.alert"
      via: "aggregation queries"
      pattern: "prisma\\.(appointment|alert)\\."
    - from: "kpi-calculator.ts"
      to: "prisma.appointment + prisma.alert"
      via: "count and aggregate queries"
      pattern: "prisma\\.(appointment|alert)\\."
---

<objective>
Implement core analytics algorithms for alert prioritization, pattern detection, and KPI calculation.

Purpose: Foundation for smart features - these algorithms power all analytics UI and predictions.
Output: Three algorithm modules that can be composed by API endpoints.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing metrics infrastructure
@src/lib/api/metrics.ts
@src/components/dashboard/metrics-dashboard.tsx
@src/components/patients/patient-stats.tsx

# Schema for understanding data models
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Priority Scorer Algorithm</name>
  <files>src/lib/analytics/priority-scorer.ts</files>
  <action>
    Create heuristic-based priority scoring algorithm (1-100 scale).

    **Priority Factors:**
    1. Alert type weight (urgent: +40, high: +25, low: +10)
    2. Alert age (older = higher priority, max +20 for >24h)
    3. Patient history (high no-show rate = +15, many cancellations = +10)
    4. Appointment proximity (within 24h = +15, within 2h = +25)

    **Interface:**
    ```typescript
    export interface PriorityFactors {
      typeWeight: number
      ageWeight: number
      patientHistoryWeight: number
      appointmentProximityWeight: number
    }

    export interface PriorityResult {
      score: number // 1-100
      factors: PriorityFactors
      explanation: string
    }

    export async function calculateAlertPriority(
      alertId: string
    ): Promise<PriorityResult>
    ```

    **Implementation notes:**
    - Use prisma to fetch alert + patient + appointment data
    - Calculate each factor independently
    - Sum factors with normalization to 1-100 range
    - Include explanation string for UI display
    - Handle missing relationships gracefully (patient/appointment may be null)
  </action>
  <verify>
    - File exists with exported functions
    - TypeScript compiles: npx tsc --noEmit
    - No prisma errors
  </verify>
  <done>
    Priority scorer algorithm implemented with 4 weighted factors, returns 1-100 score with explanation
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Pattern Detector Algorithm</name>
  <files>src/lib/analytics/pattern-detector.ts</files>
  <action>
    Create pattern detection for recurring failures using SQL aggregation.

    **Pattern Types to Detect:**
    1. Time-slot patterns: "X no-shows for Y:00 on Weekday"
    2. Provider patterns: "X failures with Provider Y"
    3. Alert type patterns: "X handoff_erro alerts in last 7 days"
    4. Day-of-week patterns: "Tuesdays have 2x more cancellations"

    **Interface:**
    ```typescript
    export type PatternType =
      | 'time_slot_noshow'
      | 'provider_failure'
      | 'alert_type_spike'
      | 'day_of_week'

    export interface Pattern {
      type: PatternType
      description: string
      count: number
      severity: 'info' | 'warning' | 'critical'
      metadata: Record<string, unknown>
      detectedAt: Date
    }

    export async function detectPatterns(options?: {
      lookbackDays?: number // default 30
      minOccurrences?: number // default 3
    }): Promise<Pattern[]>
    ```

    **Implementation notes:**
    - Use Prisma groupBy for aggregations
    - Use date-fns for day-of-week and time extraction
    - Minimum 3 occurrences to be considered a pattern
    - Sort by severity (critical > warning > info)
    - Limit to top 10 patterns to avoid noise
  </action>
  <verify>
    - File exists with exported functions
    - TypeScript compiles: npx tsc --noEmit
  </verify>
  <done>
    Pattern detector returns array of Pattern objects with 4 pattern types detected
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Extended KPI Calculator</name>
  <files>src/lib/analytics/kpi-calculator.ts</files>
  <action>
    Create extended KPI calculations beyond existing metrics.

    **KPIs to Calculate:**
    1. Booking success rate: (completed + confirmed) / total appointments
    2. No-show rate: no_show / total appointments
    3. Cancellation rate: cancelled / total appointments
    4. Average alert resolution time: avg(resolvedAt - createdAt)
    5. Alert volume by type: count per AlertType
    6. Confirmation rate trend: comparison to previous period

    **Interface:**
    ```typescript
    export interface KPIMetrics {
      bookingSuccessRate: number // percentage
      noShowRate: number // percentage
      cancellationRate: number // percentage
      avgResolutionTimeMinutes: number | null
      alertVolumeByType: Record<AlertType, number>
      confirmationRateTrend: 'up' | 'down' | 'stable'
      period: {
        start: Date
        end: Date
      }
    }

    export async function calculateKPIs(options?: {
      startDate?: Date
      endDate?: Date // default: now
      periodDays?: number // default: 30
    }): Promise<KPIMetrics>
    ```

    **Implementation notes:**
    - Build on existing src/lib/api/metrics.ts patterns
    - Use Prisma aggregate queries
    - Calculate trend by comparing current period to previous period of same length
    - Handle edge case of no data (return null for resolution time, 0 for rates)
    - Use date-fns for date math
  </action>
  <verify>
    - File exists with exported functions
    - TypeScript compiles: npx tsc --noEmit
  </verify>
  <done>
    KPI calculator returns comprehensive metrics including rates, trends, and resolution time
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All three files created in src/lib/analytics/
- [ ] `npx tsc --noEmit` passes without errors
- [ ] Each file exports documented interfaces and functions
- [ ] No runtime errors when importing modules
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Algorithms are ready to be consumed by API endpoints
- No external dependencies added (using existing prisma + date-fns)
</success_criteria>

<output>
After completion, create `.planning/phases/08-analytics-smart-features/08-01-SUMMARY.md`
</output>
