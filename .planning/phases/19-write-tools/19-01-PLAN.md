---
phase: 19-write-tools
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - src/lib/idempotency/idempotency-service.ts
  - src/lib/services/appointment-write-service.ts
  - src/app/api/agent/agendamentos/route.ts
autonomous: true

must_haves:
  truths:
    - "AI Agent can create appointments via POST /api/agent/agendamentos"
    - "Duplicate requests with same idempotency key return cached response"
    - "Conflicting time slots are rejected with 409 status"
    - "Appointment creation triggers N8N webhook (fire-and-forget)"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "IdempotencyKey model"
      contains: "model IdempotencyKey"
    - path: "src/lib/idempotency/idempotency-service.ts"
      provides: "Idempotency key management"
      exports: ["checkIdempotencyKey", "storeIdempotencyResult", "hashRequestBody"]
    - path: "src/lib/services/appointment-write-service.ts"
      provides: "Appointment creation with conflict detection"
      exports: ["createAppointment"]
    - path: "src/app/api/agent/agendamentos/route.ts"
      provides: "POST handler for appointment creation"
      exports: ["POST"]
  key_links:
    - from: "src/app/api/agent/agendamentos/route.ts"
      to: "src/lib/services/appointment-write-service.ts"
      via: "import createAppointment"
      pattern: "import.*createAppointment.*from.*appointment-write-service"
    - from: "src/lib/services/appointment-write-service.ts"
      to: "src/lib/calendar/conflict-detection.ts"
      via: "import findConflicts"
      pattern: "import.*findConflicts.*from.*conflict-detection"
    - from: "src/app/api/agent/agendamentos/route.ts"
      to: "src/lib/idempotency/idempotency-service.ts"
      via: "import checkIdempotencyKey"
      pattern: "import.*checkIdempotencyKey.*from.*idempotency"
---

<objective>
Implement POST /api/agent/agendamentos with idempotency support and conflict detection.

Purpose: Enable AI Agent to create appointments via API with automatic duplicate prevention and time slot conflict checking. This fulfills WRITE-01 requirement.

Output:
- IdempotencyKey model in Prisma schema
- Idempotency service for key management
- Appointment write service with conflict detection
- POST endpoint in agendamentos route
</objective>

<execution_context>
@/Users/gilberto/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gilberto/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-write-tools/19-RESEARCH.md

# Phase 17-18 foundations
@src/lib/agent/middleware.ts
@src/lib/agent/error-handler.ts
@src/lib/validations/agent-schemas.ts
@src/lib/audit/logger.ts

# Existing conflict detection (Phase 4)
@src/lib/calendar/conflict-detection.ts
@src/lib/calendar/n8n-sync.ts

# Current route (to extend with POST)
@src/app/api/agent/agendamentos/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add IdempotencyKey model to Prisma schema</name>
  <files>prisma/schema.prisma</files>
  <action>
Add IdempotencyKey model to the Prisma schema for storing idempotency keys:

```prisma
// Idempotency key storage for agent API
// Keys expire after 24 hours to prevent unbounded growth
model IdempotencyKey {
  id          String   @id @default(uuid()) @db.Uuid
  key         String   @unique               // Client-provided UUID
  requestHash String   @map("request_hash")  // SHA-256 of request body
  response    Json     @db.JsonB             // Cached response
  createdAt   DateTime @default(now()) @map("created_at")
  expiresAt   DateTime @map("expires_at")    // TTL for cleanup

  @@index([expiresAt])
  @@map("idempotency_keys")
}
```

Place after the Agent model. Run `npx prisma generate` and `npx prisma db push` to apply.
  </action>
  <verify>
Run: `npx prisma generate` and `npx prisma db push --accept-data-loss`
Verify IdempotencyKey model exists: `grep -A 10 "model IdempotencyKey" prisma/schema.prisma`
  </verify>
  <done>IdempotencyKey model added to schema and database table created</done>
</task>

<task type="auto">
  <name>Task 2: Create idempotency service</name>
  <files>src/lib/idempotency/idempotency-service.ts</files>
  <action>
Create new file `src/lib/idempotency/idempotency-service.ts` with:

1. `checkIdempotencyKey(key: string, requestHash: string)` - Checks if key exists:
   - If not exists: return `{ isNew: true }`
   - If exists but hash mismatch: throw Error('Idempotency key reused with different request body')
   - If exists and hash matches: return `{ isNew: false, storedResponse: existing.response }`

2. `storeIdempotencyResult(key: string, requestHash: string, response: unknown)` - Stores result:
   - Create IdempotencyKey with 24-hour TTL (expiresAt = now + 24h)
   - Store response as JSON

3. `hashRequestBody(body: unknown)` - Creates SHA-256 hash of JSON body:
   - `crypto.createHash('sha256').update(JSON.stringify(body)).digest('hex')`

4. `cleanupExpiredKeys()` - Deletes expired keys (for future cron job)

Use existing patterns from Phase 17-18:
- Import prisma from '@/lib/prisma'
- Use TypeScript interfaces for return types
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit src/lib/idempotency/idempotency-service.ts`
  </verify>
  <done>Idempotency service created with all four functions exported</done>
</task>

<task type="auto">
  <name>Task 3: Create appointment write service with conflict detection</name>
  <files>src/lib/services/appointment-write-service.ts</files>
  <action>
Create new file `src/lib/services/appointment-write-service.ts` implementing `createAppointment()`:

1. Interface `CreateAppointmentInput`:
   - pacienteId: number
   - servicoId?: number
   - tipoConsulta?: string
   - profissional?: string
   - dataHora: TZDate
   - observacoes?: string

2. Function `createAppointment(input, agentContext)`:
   a. Validate patient exists (prisma.patient.findUnique)
   b. Get service duration from Servico if servicoId provided, else default 30 min
   c. Create TimeSlot with buffer time (use addBufferTime from conflict-detection.ts)
   d. Fetch existing appointments for same day/provider
   e. Convert to TimeSlot array and call findConflicts()
   f. If conflicts exist, throw Error('Time slot already booked')
   g. Create appointment using prisma.appointment.create with include for patient
   h. Call notifyN8NAppointmentCreated (fire-and-forget with .catch(console.error))
   i. Return created appointment

Use Prisma $transaction for steps d-g to prevent race conditions.

Import from existing:
- `findConflicts`, `addBufferTime`, `TimeSlot` from '@/lib/calendar/conflict-detection'
- `notifyN8NAppointmentCreated` from '@/lib/calendar/n8n-sync'
- `prisma` from '@/lib/prisma'
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit src/lib/services/appointment-write-service.ts`
  </verify>
  <done>Appointment write service created with createAppointment function using transaction</done>
</task>

<task type="auto">
  <name>Task 4: Add POST handler to agendamentos route</name>
  <files>src/app/api/agent/agendamentos/route.ts</files>
  <action>
Add POST export to existing route file (keep existing GET handler):

1. Import new dependencies:
   - `createAppointment` from '@/lib/services/appointment-write-service'
   - `checkIdempotencyKey`, `storeIdempotencyResult`, `hashRequestBody` from '@/lib/idempotency/idempotency-service'
   - `agentCreateAppointmentSchema` from '@/lib/validations/agent-schemas' (already exists)

2. Implement POST handler wrapped with withAgentAuth:
   a. Parse and validate body with agentCreateAppointmentSchema
   b. If idempotencyKey provided:
      - Hash request body
      - Check idempotency key
      - If not new, return cached response
   c. Call createAppointment(input, agentContext)
   d. Format response with id, dataHora, tipoConsulta, profissional, status, paciente
   e. If idempotencyKey provided, store result
   f. Audit log with AGENT_CREATE_APPOINTMENT action
   g. Return successResponse(response, 201)

3. Error handling:
   - 'Time slot already booked' -> errorResponse('Horario ja ocupado', 409)
   - 'Patient not found' -> handled by handleApiError (404)
   - Zod errors -> handled by handleApiError (400)
   - 'Idempotency key reused...' -> errorResponse(message, 422)
  </action>
  <verify>
Start dev server and test with curl:
```bash
curl -X POST http://localhost:3051/api/agent/agendamentos \
  -H "Authorization: Bearer test-api-key" \
  -H "Content-Type: application/json" \
  -d '{"pacienteId": 1, "tipoConsulta": "Consulta", "dataHora": "2026-01-25T14:00:00-03:00"}'
```
Should return 401 (invalid key) or 201 (if test agent exists). Verify no TypeScript errors.
  </verify>
  <done>POST handler added with idempotency, conflict detection, and audit logging</done>
</task>

</tasks>

<verification>
1. Prisma schema compiles: `npx prisma generate`
2. TypeScript compiles: `npx tsc --noEmit`
3. Test idempotency: Create appointment twice with same key - second should return cached
4. Test conflicts: Create two appointments at same time - second should return 409
5. Test validation: Send invalid body - should return 400 with Zod errors
6. Audit log contains AGENT_CREATE_APPOINTMENT entries
</verification>

<success_criteria>
- POST /api/agent/agendamentos creates appointments with patient validation
- Same idempotency key returns cached response (not duplicate creation)
- Conflicting time slots rejected with 409 Conflict status
- N8N webhook called on successful creation (fire-and-forget)
- Audit log captures all creation attempts with agentId and correlationId
</success_criteria>

<output>
After completion, create `.planning/phases/19-write-tools/19-01-SUMMARY.md`
</output>
